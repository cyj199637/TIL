# 02. 자바와 절차적/구조적 프로그래밍

## 01. 자바 프로그램의 개발과 구동

* JDK(자바 개발 도구): JVM용 소프트웨어 개발 도구
* JRE(자바 실행 환경): JVM용 OS
* JVM(자바 가상 기계): 가상의 컴퓨터

![Java Program](../images/Java Program.png)

개발자가 사용 중인 플랫폼에 설치된 JVM용으로 프로그램을 작성하고 배포하면 각 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램을 구동하는 데 아무 문제가 없게끔 만들어주는 것이다.





## 02. 자바에 존재하는 절차적/구조적 프로그래밍의 유산

* 절차적 프로그래밍 → `goto` 를 쓰지 말라는 것

  why? 프로그램의 실행 순서가 복잡해질 수 있기 때문

* 구조적 프로그래밍 → 함수를 쓰라는 것 / 전역 변수보다는 지역 변수 사용

  * 중복 코드를 한 곳에 모아서 관리할 수 있음
  * 논리를 함수 단위로 분리해서 이해하기 쉬운 코드를 작성 가능





## 03. 다시 보는 main() 메서드: 메서드 스택 프레임

![img](../images/9988E33359A771AB09)

* static 영역: 클래스
* stack 영역: 메서드
* heap 영역: 객체

### main() 메서드 실행 준비

~~~ java
public class Start {
    public staic void main(String[] args) {
        System.our.println("Hello OOP!!!");
    }
}
~~~

![img](../images/25547C4A5695B9250A)

1. JRE가 프로그램 안에 main() 메서드가 있는지 확인

2. main() 메서드의 존재가 확인되면 JVM을 부팅

3. JVM은 목적 파일을 받아 실행

4. JVM에서 전처리 과정을 수행

   : `java.lang` 패키지, import된 패키지, 프로그램 상의 모든 클래스를 static 영역에 배치

5. main() 메서드 스택 프레임이 stack 영역에 할당 (여는 중괄호를 만나면 스텍 프레임 생성)

6. main() 메서드 인자 args를 저장할 변수 공간을 스텍 프레임에 확보

7. main() 메서드가 끝나면 스택 프레임 소멸 (닫는 중괄호를 만나면 스택 프레임 소멸)

8. JRE는 JVM을 종료하고 JRE 자체도 OS 상의 메모리에서 사라짐

   : T 메모리 소멸, JVM 기동 중지, JRE가 사용했던 시스템 자원 반납





## 06. 지역 변수와 메모리: 스택 프레임에 갇혔어요!

* 지역 변수: stack 영역 - 스택 프레임이 사라지면 함께 사라짐 → 스택 프레임에 종속적
* 클래스 멤버 변수(전역 변수): static 영역 - JVM이 종료될 때까지 사라지지 않음 → 스택 프레임에 독립적
* 객체 멤버 변수: heap 영역 - 객체와 함께 GC에 의해 사라짐

* **외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다.**





## 07. 메서드 호출과 메모리: 메서드 스택 프레임 2

~~~ java
public class Start4 {
    public static void main(String[] args) {
        int k = 5;
        int m;
        
        m = square(k);
    }
    
    private static int square(int k) {
        int result;
        
        k = 25;
        
        result = 25;
        
        return result;
    }
}
~~~



![T Memory](../images/T Memory.png)

* ?: 이전에 해당 공간의 메모리를 사용했던 다른 프로그램이 청소하지 않고 간 값

* 메소드 호출이 일어나면 무조건 호출된 메서드의 스택 프레임이 새로 생성된다.

  * 반환값을 저장할 변수 공간이 맨 아래, 인자를 저장할 변수 공간이 그 다음, 메서드의 지역 변수가 마지막으로 배치된다.
  * 반환값: 메서드가 종료되면서 반환해 줄 값을 가지고 있는 가상의 변수

* main() 메서드의 변수 k와 square() 메서드의 변수 k는 별도의 변수 공간을 가진 다른 변수다.

  : 메서드를 호출하면서 인자로 전달되는 것은 변수 자체가 아니라 변수가 저장한 값만을 복제해서 전달한다.

   → **Call By Value**

* 메서드 스택 프레임에서 다른 메서드 스택 프레임의 내부 변수에 접근 불가

  * 입력 값들과 반환값에 의해서만 메서드 사이에서 값이 전달됨



### 메서드 간 지역 변수를 참조하지 못하는 이유

* 서로의 고유 공간이기 때문
* 메서드 간 지역 변수를 참조하려면 해당 변수 공간을 정확히 알기 위해서 포인터가 필요하지만 자바는 포인터가 없음
  * 포인터: 메모리 주소 값





## 08. 전역 변수와 메모리: 전역 변수 쓰지 말라니까요!

* 클래스가 T 메모리 static 영역에 배치될 때 전역 변수도 그 안에 공간을 만들어 저장된다.

### 전역 변수를 사용하지 말아야 하는 이유

전역 변수는 여러 메서드에서 공유해서 사용할 수 있다. 만약 여러 메서드에서 전역 변수의 값을 변경한다면 T 메모리로 추적하지 않는 이상 전역 변수에 저장돼 있는 값을 파악하기 어렵기 때문이다. 대신 읽기 전용으로 값을 공유해서 전역 상수로 쓰는 것은 좋다.





## 09. 멀티 스레드 / 멀티 프로세스의 이해

* **멀티 스레드**
  * 하나의 T 메모리만 사용 → 스택 영역만 스레드 개수만큼 분할해서 사용
  * 스택 영역에는 서로 접근할 수 없지만, 스태틱 & 힙 영역은 공유해서 사용할 수 있어 멀티 프로세스 대비 메모리를 적게 사용할 수 있음
  * 쓰기 가능한 전역 변수를 사용하게 되면 스레드 안전성이 깨짐
* **멀티 프로세스**
  * 프로세스마다 각자의 T 메모리를 사용
  * 각자 고유의 공간이므로 다른 프로세스의 메모리 영역을 침범할 수 없어 안전하지만, 메모리 사용량이 그만큼 늘어남