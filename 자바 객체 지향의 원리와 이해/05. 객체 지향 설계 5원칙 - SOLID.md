# 05. 객체 지향 설계 5원칙 - SOLID

### 객체 지향 설계 원칙

: 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 원칙. 응집도는 높이고(High Cohesion), 결합도는 낮추라(Loose Coupling)는 고전 원칙을 객체 지향의 관점에서 재정립한 것

* 결합도: 모듈(클래스) 간의 상호 의존 정도.

  → 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이

* 응집도: 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성

  → 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이



## 01. SRP - 단일 책임 원칙

`어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다. - 로버트 C.마틴`

: **클래스를 역할과 책임에 따라 분리해서 각각 하나의 역할과 책임만 갖게 해야 한다.**

- 객체 지향 4대 특성 중 추상화와 가장 관계가 깊음



### SRP를 지키지 않은 경우

메서드가 SRP를 지키지 않을 경우 나타나는 대표적인 냄새가 if문

1. 하나의 역할에만 해당하는 속성이 클래스에 정의된 경우(p.179~p.180: 사람 클래스 - 군번 속성)

   → 문제: 해당 속성이 필요없는 객체도 해당 속성에 값을 할당하거나 값을 읽어오려 할 수 있음

   → 해결: 해당 클래스를 역할에 따라 다른 클래스로 분리한다. 분리된 클래스 간 공통점이 많다면 기존 클래스를 상위 			  클래스로 해서 공통점을 기존 클래스에 두고 분리된 클래스들은 상위 클래스를 상속하고 차이점만 각자 구			  현한다.

2. 하나의 속성이 여러 의미를 갖는 경우(p.180~p.181: 강아지 클래스 - 성별 속성 - 소변보다() 메서드)

   → 문제: 속성의 의미에 따라 관련 메서드에서 로직을 다르게 처리하기 위해 잦은 분기 처리가 진행될 수 있음

   → 해결: 속성의 의미에 따라 다른 클래스로 분리한다. 관련 메서드는 추상 메서드로 정의하고, 분리된 클래스에서 이			  에 대한 로직을 속성에 맞게 각각 구현한다.





## 02. OCP - 개방 폐쇄 원칙

`소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.   - 로버트 C.마틴`

: **자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.**

* OCP를 지키지 않으면 유연성, 재사용성, 유지보수성 등을 얻을 수 없음



### OCP가 적용된 사례

1. JDBC

   : 자바 애플리케이션은 JDBC 인터페이스라고 하는 완충 장치로 인해 DB를 교체하더라도 영향을 받지 않는다.  (Conenction 설정 부분을 별도의 설정 파일로 분리해두면 클라이언트 코드는 단 한 줄도 변경할 필요가 없다.)

   → 자바 애플리케이션 입장에서는 DB라고 하는 주변의 변화에 닫혀 있고, DB 입장에서는 자신의 확장에 열려 있음

2. 자바

   : 개발자의 자바 소스코드와 OS별 JVM 사이에는 목적 파일(.class)이라고 하는 완충 장치가 있어 소스코드가 어떤 OS 상에서 구동될지에 대해 걱정하지 않는다. 각 OS별 JVM과 목적 파일(.class)이 있기에 개발자는 다양한 구동 환경에 대해서는 걱정하지 않고 본인이 작업하고 있는 개발 PC에 설치된 JVM에서 구동되는 코드만 작성하면 된다.

   → 소스코드는 OS의 변화에 닫혀 있고, 각 OS별 JVM은 확장에 열려 있음



## 03. LSP - 리스코프 치환 원칙

`서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. -로버트 C.마틴`

: **하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.**

![img](../images/010.jpg)

​														리스코프 치환 원칙 위반 사례 -계층도 / 조직도

![img](../images/011.jpg)

​																리스코프 치환 원칙 적용 사례 - 분류도





## 04. ISP - 인터페이스 분리 원칙

`클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다. - 로버트 C.마틴`

* SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다. 그러나 특별한 경우가 아니라면 SRP를 적용하는 것이 낫다.
* **인터페이스 최소주의 원칙**: 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공해야 한다.



### 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋은 이유

* 빈약한 상위 클래스인 경우

  : 객체 참조 변수는 상위 클래스 타입으로 정의했지만 객체 생성은 하위 클래스로 했을 때, 상위 클래스로 사용 불가능한 속성이나 메서드가 많아 상속의 혜택을 제대로 누리지 못하고 계속해서 형변환이 발생할 수 있다.

* 풍성한 인터페이스인 경우

  : 예를 들어, A 역할과 B 역할이 섞여 있는 인터페이스 C 가 있다고 가정해보자. 개발자가 A 역할을 부여하기 위해 인터페이스 C를 구현한 D 클래스를 만들었다. 하지만 개발자가 실수로라도 B 역할과 관련된 인터페이스 기능을 클래스 D 안에서 사용할 수 도 있게 된다.





## 05. DIP - 의존 역전 원칙

`고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.`

`추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.`

`자주 변경되는 구체 클래스에 의존하지 마라 - 로버트 C.마틴`

: **자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 해야 한다.**

→ 자신보다 변하기 쉬운 것에 의존하지 않아야 함

* 사례: JDBC 등





## 06. 정리 - 객체 지향 세계와 SOLID

SoC를 적용하면 자연스럽게 SRP, ISP, OCP에 도달하게 된다.

* **SoC(관심사의 분리)**: 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 								  따로 떨어져 서로 영향을 주지 않도록 분리하는 것

  → 하나의 속성/메서드/클래스/모듈/패키지 등에는 하나의 관심사만 들어 있어야 함

  → 관심사가 다르고 변화의 시기가 다르면 분리해야 함



SOLID 원칙을 적용하면 소스 파일의 개수는 더 많아질 수 있으나, 논리를 더욱 잘 분할하고, 잘 표현하기에 이해하기 쉽고, 개발하기 쉬우며, 유지보수성이 높아진다.