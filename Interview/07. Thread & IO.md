# 07. Thread & IO

(볼드체로 표시한 부분도 답변 준비할 것)

## 스레드를 사용하는 이유가 무엇인가?

- cpu 코어를 최대한 사용해서 많은 일들을 동시에 처리해야된다.

- 스레드를 적정한 수보다 늘려야 하는 상황? - 블로킹 I/O가 일어나면 어떤 스레드는 멈춰있기 때문에 스레드를 더 생성할 수 있다.

- IO - 스레드 관련해서 자바의 신2권에서 공부하기

- NIO - 논블로킹

- 그럼 스레드를 무조건 많이 사용하는 것이 좋은가?

  : 컨텍스트 스위칭



## 스레드의 상태변수에 대해 가시성이 보장되지 않는 이유?



## Thread-Safe의 의미가 무엇인가?



## 객체를 안전하게 공유하지 않으면 생기는 문제점이 무엇인가?

* 그럼 객체를 안전하게 공유하려면 어떻게 해야하는가?



## Tomcat Thread에 대해 설명해보시오



## 멀티스레드 환경에서 동기화를 위해 사용할 수있는 예약어가 무엇인가?

- synchronized

  - synchronized를 사용하면 왜 느려지는가?: 모니터 객체
  - 락이 걸리는 범위

- volatile

  : 원래 스레드들은 변수를 자기 고유의 캐시에만 저장되어있어서 다른 스레드들은 그 값이 변경되었는지 모르는데 volatile은 객체가 모든 스레드에 공유되는 메모리에 바로 반영되어서 가시성이 보장됨



## 스레드 로컬 변수는 어떻게 생성되고 어떻게 회수되나?





## IO가 있는데 왜 NIO가 나왔나?

IO는 동기/Blocking 만 지원한다. 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking) 한다. 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다. 그러나 (이벤트 루프를 이용한) 비동기식 호출 방식에서는 스레드가 응답을 기다리지 않고 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리하다가 응답이 왔을 때 해당 일을 처리한다. 따라서, 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없어지며, 적은 수의 스레드들로 요청을 처리할 수 있다.

IO: 연결 클라이언트의 수가 적고, 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우

(NIO는 **버퍼**를 사용하고 데이터를 읽어올 때, 버퍼에 무조건 저장하게 되는데 데이터가 대용량이면 이 버퍼의 크기를 키워야하지만 그 크기를 무한정 늘릴 수 없기 때문)

* 버퍼: 읽고 쓰기 가능한 메모리 배열
  * 논 다이렉트 버퍼: JVM이 관리하는 힙 메모리 공간을 이용하는 버퍼
    * 버퍼 생성 시간이 빠르지만 OS가 JVM에게 할당한 크기만큼만 사용할 수 있음
    * 논 다이렉트 버퍼 → 임시 다이렉트 버퍼 → OS 순으로 입출력이 처리되어 다이렉트 버퍼보다 성능이 낮음
  * 다이렉트 버퍼: JVM이 관리하지 않고 OS가 관리하는 메모리 공간을 이용하는 버퍼
    * OS 함수 호출과 잡다한 처리 등으로 버퍼 생성 시간은 느리지만 OS가 허용하는 범위 내에서 대용량 버퍼를 생성할 수 있음
    * 자주 생성하기 보다는 한 번 생성해놓고 재사용하는 곳에서 적합

NIO: 연결 클라이언트의 수가 많고, 전송되는 데이터 용량이 적으면서 입출력 작업 처리가 빨리 끝나는 경우

(NIO를 사용하게 되면 스레드 풀을 사용하게 되는데, 스레드 풀의 스레드 수는 한정적인데 작업 처리가 오래 걸리게 되면 작업 큐에 많은 작업들이 쌓이게 되고, 그만큼 레이턴시가 길어져 성능이 나빠지기 때문)



## NIO가 있는데 왜 Netty를 사용하나?

직접 NIO API를 이용해 Non-blocking 입출력을 올바르고 안전하게 구현하는 것은 어려우며 더 복잡해질 수 있다. 특히 부하가 높은 상황에 입출력을 안정적이고 효율적으로 처리하고 호출하는 것과 같이 까다롭고 문제 발생 위험이 높을수록 전문가에 대한 의존성이 높아진다. 따라서 기반 구현의 복잡성을 단순한 추상화로 감추는 객체 지향의 기본 개념을 도입해야 한다. 이러한 이유로 네티는 자바의 NIO API를 캡슐화하고 사용하기 쉬운 API를 내세워 개발자가 비즈니스 로직 개발에 집중할 수 있게 한다.



## Webfulx란 무엇인가?

https://madplay.github.io/post/web-on-reactive-stack-spring-webflux

https://www.baeldung.com/spring-webflux-concurrency

### Webflux는 어떨 때 성능이 빠르고, 어떨 때 성능이 느린가?

동시 접속자가 많을수록 기존 Spring MVC의 응답 속도보다 더 빠르다. 그러나 처음부터 끝까지 비동기-Non Blocking 구조로 구성이 되어 있어야 유의미하다. 어플리케이션 로직 중에 하나라도 Blocking 으로 동작하는 것이 있다면 성능이 느리다. (ex. RDBMS와 같은 데이터 액세스를 호출하는 리포지토리, HTTP API 호출, 기타 네트워크를 이용하는 서비스 등)

### 기존 Spring MVC는 비동기 방식을 지원하지 않는가?

https://www.baeldung.com/spring-mvc-async-vs-webflux

### 그럼 Webflux가 Spring MVC보다 빠른가?

**리액티브**와 논 블로킹은 어플리케이션의 실행 속도를 향상시키지 못한다. 몇몇 경우에 한하여 더 빨라질 수는 있다(예로, 병렬로 웹클라이언트를 사용하여 원격 호출을 실행할 때). 대체로 논 블로킹 방식은 더 많은 작업량을 필요로 하며, 이는 요청 처리 시간을 약간 늘어나게 할 수 있다.

리액티브와 논 블로킹을 사용할 때의 주요 이점은 적은 수의 고정된 스레드와 보다 적은 메모리로 확장할 수 있다는 것이다. 이는 어플리케이션이 예측 가능한 방식으로 확장되기 때문에 부하에 대해 더 탄력적으로 동작할 수 있도록 한다. 하지만 이러한 이점을 보려면 약간의 지연을 필요로 한다(느리고 예측 불가능한 네트워크 I/O의 혼재로 인해). 여기서 리액티브 스택의 장점을 볼 수 있으며, 그 차이가 극적으로 나타날 수 있다.

→ 적은 스레드와 메모리를 효율적으로 사용할 수 있는 것이기 때문에 "속도가 빠르다" 보다는 "적은 리소스로 많은 트래픽을 감당한다" 고 할 수 있다. / Webflux는 꼭 성능 때문만이 아니라 함수형 스타일 코드를 이용해 간결하고 읽기 좋고 조합하기 편한 코드를 작성할 수 있다. 데이터 흐름에 다양한 오퍼레이터를 적용시킬 수 있고, 연산을 조합해서 만든 동시성 정보가 노출되지 않는 추상화된 코드를 작성할 수 있다. 데이터의 흐름의 속도를 제어할 수 있는 메커니즘도 제공한다.



## Webflux와 Netty, RDBMS를 같이 사용하면 무엇이 안 좋은가?

Webflux와 Netty는 비동기, Non-blocking IO 구조이고, RDBMS는 동기, Blocking IO 구조이다. 앞에서 비동기 방식으로 효율적으로 작업을 처리해도 작업 중에 데이터 액세스 작업이 있다면 이에 대한 처리를 위해 스레드가 블락된다. 그런데 동기 방식과 달리 비동기 방식은 스레드의 수가 적기 때문에 하나라도 멈추게 되면 성능이 안 좋아진다.



## 트래픽이 많아질 때 왜 비동기 방식이 동기 방식보다 좋은가?