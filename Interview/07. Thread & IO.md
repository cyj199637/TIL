# 07. Thread & IO

동시성 - 하나의 코어에서 여러 스레드를 돌아가면서 실행시키는 것

병렬성 - 여러 개의 코어에서 하나의 스레드씩 실행시키는 것

## IO가 있는데 왜 NIO가 나왔나?





## NIO가 있는데 왜 Netty를 사용하나?





## Webfulx란 무엇인가?

https://madplay.github.io/post/web-on-reactive-stack-spring-webflux

https://www.baeldung.com/spring-webflux-concurrency

### Webflux는 어떨 때 성능이 빠르고, 어떨 때 성능이 느린가?

동시 접속자가 많을수록 기존 Spring MVC의 응답 속도보다 더 빠르다. 그러나 처음부터 끝까지 비동기-Non Blocking 구조로 구성이 되어 있어야 유의미하다. 어플리케이션 로직 중에 하나라도 Blocking 으로 동작하는 것이 있다면 성능이 느리다. (ex. RDBMS와 같은 데이터 액세스를 호출하는 리포지토리, HTTP API 호출, 기타 네트워크를 이용하는 서비스 등)

### 기존 Spring MVC는 비동기 방식을 지원하지 않는가?

https://www.baeldung.com/spring-mvc-async-vs-webflux

### 그럼 Webflux가 Spring MVC보다 빠른가?

리액티브와 논 블로킹은 어플리케이션의 실행 속도를 향상시키지 못한다. 몇몇 경우에 한하여 더 빨라질 수는 있다(예로, 병렬로 웹클라이언트를 사용하여 원격 호출을 실행할 때). 대체로 논 블로킹 방식은 더 많은 작업량을 필요로 하며, 이는 요청 처리 시간을 약간 늘어나게 할 수 있다.

리액티브와 논 블로킹을 사용할 때의 주요 이점은 적은 수의 고정된 스레드와 보다 적은 메모리로 확장할 수 있다는 것이다. 이는 어플리케이션이 예측 가능한 방식으로 확장되기 때문에 부하에 대해 더 탄력적으로 동작할 수 있도록 한다. 하지만 이러한 이점을 보려면 약간의 지연을 필요로 한다(느리고 예측 불가능한 네트워크 I/O의 혼재로 인해). 여기서 리액티브 스택의 장점을 볼 수 있으며, 그 차이가 극적으로 나타날 수 있다.

→ 적은 스레드와 메모리를 효율적으로 사용할 수 있는 것이기 때문에 "속도가 빠르다" 보다는 "적은 리소스로 많은 트래픽을 감당한다" 고 할 수 있다. / Webflux는 꼭 성능 때문만이 아니라 함수형 스타일 코드를 이용해 간결하고 읽기 좋고 조합하기 편한 코드를 작성할 수 있다. 데이터 흐름에 다양한 오퍼레이터를 적용시킬 수 있고, 연산을 조합해서 만든 동시성 정보가 노출되지 않는 추상화된 코드를 작성할 수 있다. 데이터의 흐름의 속도를 제어할 수 있는 메커니즘도 제공한다.



## Webflux는 Netty를 사용하고 Netty는 Non-blocking IO를 사용한다. RDBMS는 Blocking IO다. 무엇이 안 좋은가?

### 왜 Non-blocking IO와 Blocking IO를 같이 사용하면 안 좋은가?
