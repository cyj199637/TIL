# 08. Thread & IO

(볼드체로 표시한 부분도 답변 준비할 것)

## 스레드를 사용하는 이유가 무엇인가?

- cpu 코어를 최대한 사용해서 많은 일들을 동시에 처리해야된다.

- 스레드를 적정한 수보다 늘려야 하는 상황? - 블로킹 I/O가 일어나면 어떤 스레드는 멈춰있기 때문에 스레드를 더 생성할 수 있다.

- IO - 스레드 관련해서 자바의 신2권에서 공부하기

- NIO - 논블로킹

- 그럼 스레드를 무조건 많이 사용하는 것이 좋은가?

  : 컨텍스트 스위칭



## 스레드의 상태변수에 대해 가시성이 보장되지 않는 이유?

원래 스레드들은 변수를 자기 고유의 캐시에만 저장되어있어서 다른 스레드들은 그 값이 변경되었는지 모르는데



## Thread-Safe?

- hread safe?

: "쓰레드에 안전하다"는 것은 멀티 쓰레드 환경에서 어떤 변수나 메소드, 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻한다. 예를 들어, 하나의 쓰레드가 어떤 메소드를 호출하여 실행하고 있는 동시에 다른 쓰레드가 같은 메소드를 호출하여 실행해도 각 쓰레드에서 결과가 올바르게 나와야 한다는 것을 뜻한다.

이처럼 `Thread safe` 하게 코드를 짜려면 여러 가지 방법이 있는데 대표적으로 아래 3가지의 방식이 있다.

1. `synchronized`

: 여러 쓰레드가 같은 객체를 참조할 때, 해당 객체에 `synchronized`로 처리된 부분이 있다면 여러 쓰레드가 접근하여 그 부분을 수행하려 해도 한 번에 하나의 쓰레드만 수행할 수 있고, 다른 쓰레드들은 쓰레드가 실행을 마칠 때까지 기다려야 한다.

- 사용 방법
  - 메소드를 `synchronized`로 선언
  - `synchronized` 블록

2. Immutable Object

: 불변 객체란 생성 후 그 상태를 바꿀 수 없는 객체를 뜻한다. 즉, 객체가 참조하고 있는 값이 외부에서 임의로 변경되지 않는 객체이다. 특히, 멀티 쓰레드 환경에서 데이터가 불변 객체에 저장돼 있다면 여러 쓰레드에 의해서 특정 쓰레드의 데이터가 변경될 우려가 없다. 그러나 다른 값으로 변경하고 싶은 경우, 기존 값을 수정할 수 없어 계속해서 새로운 객체를 생성하기 때문에 이로 인한 성능 저하가 발생할 수 있다.

- 불변 객체 생성 방법
  - 모든 필드를 `final` 로 선언
  - 모든 필드를 `private` 로 선언
  - `setter` 를 구현하지 않는다.

3. Stateless Code

: `Stateless` 하다는 것은 이전의 상태를 기억하지 않는다는 것이다. 여기서 상태란 객체의 상태, 즉 객체의 인스턴수 변수 값을 의미한다. 예를 들어, `stateless` 한 메소드나 함수는 입력 파라미터에 영향을 받지 않고, 같은 입력 값이라면 항상 같은 결과를 리턴하는 메소드나 함수를 가리킨다. 모든 쓰레드는 이러한 메소드를 안전하게 호출할 수 있으며 다른 메소드에서 개입하거나 다른 메소드의 반환된 결과로 바뀌지 않고 예상되는 결과를 얻을 수 있다. 멀티 쓰레드 환경의 에러는 대부분 여러 쓰레드들 간에 상태를 공유하기 때문에 발생하므로, `thread-safety` 를 이루려면 `stateless` 하게 코드를 짜야한다.



## 객체를 안전하게 공유하지 않으면 생기는 문제점이 무엇인가?

* 그럼 객체를 안전하게 공유하려면 어떻게 해야하는가?



## Tomcat Thread?



## 멀티스레드 환경에서 동시성을 제어할 수 있는 방법?

https://deveric.tistory.com/104



## 멀티스레드 환경에서 동기화를 위해 사용할 수있는 예약어가 무엇인가?

- synchronized

  - synchronized를 사용하면 왜 느려지는가?: 모니터 객체
  - 락이 걸리는 범위

- volatile

  : 원래 스레드들은 변수를 자기 고유의 캐시에만 저장되어있어서 다른 스레드들은 그 값이 변경되었는지 모르는데 volatile은 객체가 모든 스레드에 공유되는 메모리에 바로 반영되어서 가시성이 보장됨



## 스레드 로컬 변수는 어떻게 생성되고 어떻게 회수되나?





## IO가 있는데 왜 NIO가 나왔나?

IO는 동기/Blocking 만 지원한다. 동기식 호출 방식에서는 상대편의 응답이 올 때까지 스레드는 기다려야(blocking) 한다. 응답이 빨리 오면 그 기다림은 길지 않겠지만 만약 응답이 늦게 오면 서버가 요청에 대한 응답을 기다리는 데 스레드를 모두 소진해서 추가 요청을 처리할 수 없는 상태가 될 수 있다. 그러나 (이벤트 루프를 이용한) 비동기식 호출 방식에서는 스레드가 응답을 기다리지 않고 자신에게 할당된 다른 여러 소켓의 요청을 순차적으로 빠르게 처리하다가 응답이 왔을 때 해당 일을 처리한다. 따라서, 응답만 기다리면서 불필요하게 리소스를 점유하는 일은 없어지며, 적은 수의 스레드들로 요청을 처리할 수 있다.

IO: 연결 클라이언트의 수가 적고, 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우

(NIO는 **버퍼**를 사용하고 데이터를 읽어올 때, 버퍼에 무조건 저장하게 되는데 데이터가 대용량이면 이 버퍼의 크기를 키워야하지만 그 크기를 무한정 늘릴 수 없기 때문)

* 버퍼: 읽고 쓰기 가능한 메모리 배열
  * 논 다이렉트 버퍼: JVM이 관리하는 힙 메모리 공간을 이용하는 버퍼
    * 버퍼 생성 시간이 빠르지만 OS가 JVM에게 할당한 크기만큼만 사용할 수 있음
    * 논 다이렉트 버퍼 → 임시 다이렉트 버퍼 → OS 순으로 입출력이 처리되어 다이렉트 버퍼보다 성능이 낮음
  * 다이렉트 버퍼: JVM이 관리하지 않고 OS가 관리하는 메모리 공간을 이용하는 버퍼
    * OS 함수 호출과 잡다한 처리 등으로 버퍼 생성 시간은 느리지만 OS가 허용하는 범위 내에서 대용량 버퍼를 생성할 수 있음
    * 자주 생성하기 보다는 한 번 생성해놓고 재사용하는 곳에서 적합

NIO: 연결 클라이언트의 수가 많고, 전송되는 데이터 용량이 적으면서 입출력 작업 처리가 빨리 끝나는 경우

(NIO를 사용하게 되면 스레드 풀을 사용하게 되는데, 스레드 풀의 스레드 수는 한정적인데 작업 처리가 오래 걸리게 되면 작업 큐에 많은 작업들이 쌓이게 되고, 그만큼 레이턴시가 길어져 성능이 나빠지기 때문)



## NIO가 있는데 왜 Netty를 사용하나?

직접 NIO API를 이용해 Non-blocking 입출력을 올바르고 안전하게 구현하는 것은 어려우며 더 복잡해질 수 있다. 특히 부하가 높은 상황에 입출력을 안정적이고 효율적으로 처리하고 호출하는 것과 같이 까다롭고 문제 발생 위험이 높을수록 전문가에 대한 의존성이 높아진다. 따라서 기반 구현의 복잡성을 단순한 추상화로 감추는 객체 지향의 기본 개념을 도입해야 한다. 이러한 이유로 네티는 자바의 NIO API를 캡슐화하고 사용하기 쉬운 API를 내세워 개발자가 비즈니스 로직 개발에 집중할 수 있게 한다.



## Webfulx란 무엇인가?

https://madplay.github.io/post/web-on-reactive-stack-spring-webflux

https://www.baeldung.com/spring-webflux-concurrency

### Webflux는 어떨 때 성능이 빠르고, 어떨 때 성능이 느린가?

동시 접속자가 많을수록 기존 Spring MVC의 응답 속도보다 더 빠르다. 그러나 처음부터 끝까지 비동기-Non Blocking 구조로 구성이 되어 있어야 유의미하다. 어플리케이션 로직 중에 하나라도 Blocking 으로 동작하는 것이 있다면 성능이 느리다. (ex. RDBMS와 같은 데이터 액세스를 호출하는 리포지토리, HTTP API 호출, 기타 네트워크를 이용하는 서비스 등)

### 기존 Spring MVC는 비동기 방식을 지원하지 않는가?

https://www.baeldung.com/spring-mvc-async-vs-webflux

### 그럼 Webflux가 Spring MVC보다 빠른가?

**리액티브**와 논 블로킹은 어플리케이션의 실행 속도를 향상시키지 못한다. 몇몇 경우에 한하여 더 빨라질 수는 있다(예로, 병렬로 웹클라이언트를 사용하여 원격 호출을 실행할 때). 대체로 논 블로킹 방식은 더 많은 작업량을 필요로 하며, 이는 요청 처리 시간을 약간 늘어나게 할 수 있다.

리액티브와 논 블로킹을 사용할 때의 주요 이점은 적은 수의 고정된 스레드와 보다 적은 메모리로 확장할 수 있다는 것이다. 이는 어플리케이션이 예측 가능한 방식으로 확장되기 때문에 부하에 대해 더 탄력적으로 동작할 수 있도록 한다. 하지만 이러한 이점을 보려면 약간의 지연을 필요로 한다(느리고 예측 불가능한 네트워크 I/O의 혼재로 인해). 여기서 리액티브 스택의 장점을 볼 수 있으며, 그 차이가 극적으로 나타날 수 있다.

→ 적은 스레드와 메모리를 효율적으로 사용할 수 있는 것이기 때문에 "속도가 빠르다" 보다는 "적은 리소스로 많은 트래픽을 감당한다" 고 할 수 있다. / Webflux는 꼭 성능 때문만이 아니라 함수형 스타일 코드를 이용해 간결하고 읽기 좋고 조합하기 편한 코드를 작성할 수 있다. 데이터 흐름에 다양한 오퍼레이터를 적용시킬 수 있고, 연산을 조합해서 만든 동시성 정보가 노출되지 않는 추상화된 코드를 작성할 수 있다. 데이터의 흐름의 속도를 제어할 수 있는 메커니즘도 제공한다.

### 리액티브?

https://engineering.linecorp.com/ko/blog/reactive-streams-with-armeria-1/

"반응형"이라는 용어는 I / O 이벤트에 반응하는 네트워크 구성 요소, 마우스 이벤트에 반응하는 UI 컨트롤러, 사용 가능한 리소스 등 변경, 가용성 및 처리 가능성에 대한 반응을 중심으로 구축된 프로그래밍 모델이다. 그런 의미에서 Non-blocking은 반응적이라고 할 수 있다. 왜냐하면 블락되지 않고 작업이 완료되거나 데이터가 사용 가능해지면 알림에 대응하는 모드에 있기 때문이다.

또한 Spring 팀에서 리액티브와 연관시키는 또 Non-blocking pressure라는 중요한 매커니즘이 있다. 동기식 명령형 코드에서 Blocking 호출은 호출자가 대기하도록하는 자연스러운 형태의 역압 역할을 한다. 비동기식 코드에서는 빠른 생산자가 목적지를 압도하지 않도록 이벤트 속도를 제어하는 것이 필수적이다.



## Webflux와 Netty, RDBMS를 같이 사용하면 무엇이 안 좋은가?

Webflux와 Netty는 비동기, Non-blocking IO 구조이고, RDBMS는 동기, Blocking IO 구조이다. 앞에서 비동기 방식으로 효율적으로 작업을 처리해도 작업 중에 데이터 액세스 작업이 있다면 이에 대한 처리를 위해 스레드가 블락된다. 그런데 동기 방식과 달리 비동기 방식은 스레드의 수가 적기 때문에 하나라도 멈추게 되면 성능이 안 좋아진다.

### R2DBC?

R2DBC는 SQL 데이터베이스를 위한 리액티브 API다.

R2DBC가 만들어진 이유 중 하나는 적은 수의 스레드로 동시성을 처리하고 더 적은 하드웨어 리소스로 확장 할 수있는 Non-blocking 애플리케이션 스택이 필요했기 때문이다. JDBC는 Blocking API이므로 표준화 된 관계형 데이터베이스 액세스 API (즉, JDBC)를 사용한다면 Webflux를 사용한다 해도 비동기 시스템의 이점을 누릴 수가 없다. `ThreadPool`로 Blocking 작업을 보완하려는데에도 한계가 있다.

또 다른 이유는 대부분의 응용 프로그램이 관계형 데이터베이스를 사용하여 데이터를 저장하기 때문이다. 여러 NoSQL 데이터베이스들은 Reactive 데이터베이스 클라이언트를 제공하지만 대부분의 프로젝트에서 NoSQL이 하나의 선택 사항이지 기본 스택이 아니다. 이것이 Non-blocking 데이터베이스 드라이버를 위한 새로운 공통 API를 만들게 된 계기다.



## 왜 트래픽이 많아질 때 비동기 방식이 동기 방식보다 좋은가?