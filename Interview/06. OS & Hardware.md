# 06. OS & Hardware

## 메모리?

넓은 의미에서는 기억 장치 전부를 뜻하지만, 좁은 의미에서는 메인 메모리(RAM)을 뜻한다.

* 컴퓨터의 유일한 작업공간

  → 프로세스는 CPU에서 밖으로 이탈할 수 없고, 반드시 메모리에 적재한 후에 실행할 수 있다.



## 메모리 단편화?

https://jeong-pro.tistory.com/91?category=793347



## 리눅스 메모리 관리?

작업공간을 필요로 하는 프로세스들을 위해 운영체제인 리눅스가 메인 메모리를 관리하고 운영하는 방법

### 가상 메모리

: 실제 디스크를 마치 메모리처럼 사용하는 것

* 프로세스 입장에서는 디스크 공간이 아닌 실제 메모리로 인식

* 메모리 오버레이가 발생했을 때, 프로세스의 나머지 부분들이 가상 메모리에 저장됨

  * 프로그램의 크기가 실제 메모리(물리 메모리)보다 클 때 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 기법

* **페이지**: 가상 메모리 시스템에서 메모리를 다룰 때 사용하는 최소 크기 단위(리눅스 - 4kb)

* **스왑 아웃**: 메인 메모리의 프로세스에서 일정 페이지를 잘라서 가상 메모리로 가져가는 것

* **스왑 인**: 가상 메모리에 옮겨 두었던 프로세스의 페이지를 다시 메인 메모리로 가져오는 것

* 가상 메모리를 사용하면 가상 메모리와 메모리의 스왑 비용때문에 큰 성능 저하가 발생

  → 스와핑이 발생하지 않도록 메모리의 여유율을 유지하는 것이 중요

* vmstat의 free, so

  * free: 사용 가능한 메모리 크기
  * so: 스왑 아웃 횟수

### 파일 캐시

: 파일 I/O 작업으로 인한 성능 저하를 개선하기 위해 한 번 읽은 파일의 내용을 캐시해두는 곳

* 파일 I/O는 상대적으로 메모리보다 속도가 느린 디스크의 리소스를 사용하는 작업이기 때문에 파일 I/O가 많이 발생하며 성능 저하가 발생함
* 한 번 읽은 파일 내용을 메모리에 캐시해 두었다가 사용
* vmstat의 buff, cache
  * buff: 파일 시스템의 메타 데이터와 관련 블록들을 저장하고 있는 캐시
  * cache: 파일 내용을 저장하고 있는 캐시



## Process vs Thread

* 프로그램: 어떤 작업을 위해 운영체제 위에서 실행할 수 있는 파일
* 프로세스: 운영 체제 위에서 실행 중인 프로그램
  * 프로그램 명령어와 데이터들이 메모리에 올라오고 실행 중 또는 실행 대기 중인 상태
* 프로세서: 프로세스가 동작될 수 있도록 하는 하드웨어 = CPU
  * 동작: 프로그램 자원들이 메모리에 올라오고, 실행 되어야 하는 코드의 메모리 주소를 CPU 레지스터로 올리는 것

### 프로세스

: 프로세서에 의해 동작하고 있는 프로그램

* 프로세스가 동작한다는 것은 프로세스의 특정 스레드가 실행 중이라는 뜻
  * 해당 스레드는 프로세스가 가진 데이터를 참조함
* 스레드 단위 작업을 지원하기 위한 자원 할당의 단위

<멀티테스킹이 가능한 이유>

* CPU는 한 순간에 하나의 프로세스만 실행할 수 있다. 하지만 운영체제가 짧은 시간에 실행할 프로세스를 수십 번에서 수천 번 교체하기 때문에 우리는 동시에 여러 개의 작업이 실행되고 있다고 느끼는 것이다.
* 프로세스를 제어하기 위한 정보 모음인 PCB를 참고하여 프로세스를 파악

<프로세스 구조>

* Stack: 호출된 함수, 지역변수 등 임시 데이터
* Heap: 동적으로 생긴 데이터 ex) new Object(), malloc()
* Data: 전역변수 ex) static 변수, global 변수
* Code: 프로그램의 코드

<멀티 프로세스의 단점>

각 프로세스가 메모리 영역을 따로 가지고 있기 때문에 비효율이 발생함

* 컨텍스트 스위칭이 발생할 때, 같은 프로그램에 대한 작업이어도 메모리 영역이 달라 기존 프로세스의 데이터를 내리고, 다음 프로세스의 데이터를 올려 로딩하는 비효율 발생
* 다른 프로세스의 정보를 사용하기 위해 통신이 필요

### 스레드

: 프로세스 내에서 실행되는 작업 흐름의 단위

<스레드의 구조>

* 하나의 프로세스 안에서 Heap, Data, Code 영역은 공유하고 Stack 영역만 따로 가지게 됨

<멀티 스레드>

* Heap, Data, Code 영역은 공유하기 때문에 같은 프로세스 안에서 다른 스레드로 바뀐다면 컨텍스트 스위칭에 걸리는 시간이 줄어듦
  * PCB는 스레드마다 할당되기 때문에 레지스터에 적재되는 것은 PCB뿐이다.
* 디버깅이 까다로움
* 한 프로세스 안의 스레드에 문제가 생기면 같은 프로세스 안의 다른 스레드에도 문제가 생김
* 같은 데이터를 공유하므로 데이터 동기화에 신경써야 함

**자원은 프로세스 단위로 받고, 작업/스케줄링은 스레드 단위로 진행함**



## 컨텍스트 스위칭?

https://jeong-pro.tistory.com/93?category=793347

프로세스가 교체되는 시점마다 어떤 프로세스가 RUN 상태에서 READY 상태로 빠지는지, 진행 중이었던 프로세스가 어디까지 진행됐는지, 다음 프로세스를 어디부터 시작해야 하는지 등의 정보에 대해 로딩해야 하는 시간