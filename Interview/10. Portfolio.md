# 10. Portfolio

## 기술 블로그를 쓰는 이유?

: 사례를 공유한다 / 지식을 공유한다 / 기술 블로그는 어떤 식으로 지식을 공유하는 걸까?에 대해 생각해보기 / 더 널리 공유하기 위해 제목도 ~~하게 짓는다.



## 우리 회사에서는 레거시 유산이 많이 남아있는데 그럼 배울 것이 없는건가?

: 근본 기술을 더 잘 배울수 있을 거다 / ~~한 기능에 대해서 로우한 코드도 볼 수 있을 거다 / 기본기가 더 탄탄해질 수 있다 / 더 불편한 코드를 사용하다 보니 객체지향이나 디자인 패턴 같은 것들에 선배들이 고민한 흔적들이 남아있을 거다 -> 배울 수 있는게 많다.



## 내부 시스템은 무엇이 다른가?

: 내부 시스템은 외부 시스템에 비해 요청마다 큰 데이터가 오가거나 요청의 복잡도가 크다. 명세서 역할을 할 테스트를 더 꼼꼼히 해야한다. 특정 지정일에 전 직원에게 문서를 뿌려야 되는데 이런걸 어떻게 해결해야 하나?



## IntelliJ를 선택한 이유?





## Maven을 선택한 이유?

https://jeong-pro.tistory.com/168?category=793347



## MySQL을 선택한 이유?

- MySQL은 언제 써야하고, NoSQL은 언제 써야하나?

  : CAP 이론



## 많은 트래픽을 견딜 수 있도록 개발했다고 하는데 그 예시?



## 재사용성을 높일 수 있도록 개발했다고 하는데 그 예시?



## Gitflow를 왜 사용했나?

- branch 전략을 찾아보다가 대기업들이 gitflow 전략을 많이 사용해서 도입을 해봤다
- 써보니까 ~~게 좋았다.
- 디벨롭 브랜치가 없어도 마스터 브랜치에 따로 테스트 서버에 복붙
- 소스 코드 관리에 대해서 공부해서 내용을 채우기

: 효율적으로 소스 코드를 관리하고 싶어 branch 전략을 찾아봤습니다. 그 중에서 Gitflow 전략을 많은 기업들이 사용하고 있어서 나의 프로젝트에도 도입을 해봤습니다. 해당 전략을 통해 기능별로 브랜치를 나누고 작업할 수 있었고, 이에 따라 해당 기능에만 초점을 맞추어 코드의 정확성과 품질을 높이는데 집중할 수 있다는 점이 좋았습니다. 또한, 코드 리뷰를 할 때 다른 사람들에게 대상 코드를 명확하게 나타낼 수 있어 코드 리딩에 소요되는 시간을 줄일 수 있었습니다.



## Readme랑 wiki를 나눠서 관리하는 이유?

- 위키를 자세히 읽고 프로젝트를 시작하는 사람들 보다는 바로 시작하는 사람들이 많다
- 그런 사람들을 위해 배려하기 위해 리드미에 간단하게 프로젝트에 대한 정보를 적는게 좋다.



## 설정 값을 외부에서 주입해야 하는 이유?



## 분산 처리 환경에서 대용량 트래픽을 고려하여 로그인 기능을 구현했다고 하는데 어떻게 구현했나?

: 사용자가 많아져서 서버를 확장해야한다고 가정했다라고 말하기(확장했다라고 단언하지 말고)
그냥 세션 데이터 불일치 문제 해결 방법을 찾아봤다라고 하기
개발자는 여러 상황에서 최선의 선택을 해야한다고 들었다. 그래서 레디스로 해결했다고는 하는데 나한테 맞는지 의구심이 들었다. 그래서 처음부터 찾아봤다.

방식에 대한 장단점을 주로 비교하지 말고 공식 도큐먼트를 주로 참고했다라고 과정을 강조하기

세션 클러스터링은 확장에 한계가 있다. 서버 대수가 늘어날 때마다 복제에 대한 비용 증가한다. 반면 세션 스토리지를 분리하면 세션 데이터가 공유되기 때문에 서버 확장으로 인한 오버헤드가 증가하지 않는다.

sns 특징이 아니라 세션에 대한 특징을 들면서 인메모리 데이터베이스 설명하기
다양한 기능을 지원해주고 스프링이 지원해줘서 유지보수성을 높이는데 도움이 될 것 같아서 레디스를 선택했다.



## Scale up가 아닌 Scale out을 선택한 이유?

: Scale up은 서버 한 대에 여러 장비를 추가하거나 교체해도 그로 인한 비용이 거의 발생하지 않고, 한 대의 서버에서 모든 요청과 데이터가 처리되기 때문에 클라이언트의 상태정보를 저장하여 stateful한 서비스를 구현하는데 수월하고 이에 대한 데이터 정합성이 보장된다는 점에서는 좋습니다. 하지만 추가할 수 있는 장비의 수도 한정적이기 때문에 성능 확장에 한계가 있으며 어느 정도의 수준까지 오면 추가된 자원 대비 효과는 미미해집니다. 그렇기 때문에 서버가 가진 최대한의 성능보다 큰 규모의 트래픽이 들어온다면 결국 버티지 못하고 부하가 발생합니다. 제가 진행했던 프로젝트는 SNS 서비스였습니다. SNS 서비스는 많은 요청을 동시에 처리할 필요가 있지만 특성상 다른 서비스에 비해 데이터 정합성 이슈에 민감하지 않습니다. 그러나 장애가 발생하여 서비스가 중지되면 중지된 시간만큼 광고가 집행되지 못해 매출에 큰 타격을 입는 등 피해 범위와 정도가 크기 때문에 가용성이 높은 Scale Out 확장 방법이 적절하다고 생각했습니다.

- Scale up을 선택하더라도 대체 서버를 여러 개 두어 문제점을 해결할 수도 있지 않나?

  : 그렇게 해결할 수도 있지만 그렇게 된다면 대체 서버는 메인 서버에 장애가 발생할 때만 사용될 뿐 평소에는 사용하지 않기 때문에 비용적인 측면에서 낭비라고 생각합니다.



## 데이터 불일치 문제를 해결하는 방법을 검색해보면 Redis만 나오지는 않던데?

- 검색 방법에 대해 얘기
- 검색했을 때 레디스 안 나오던데? 라고 질문이 들어오면 평소에 날짜 기준 이나 특정 키워드 중심으로 검색한다라고 하기



## sticky session 단점?

* sticky session에서 트래픽이 고르게 분배되지 않는 상황 말해보기
* 로드밸런서 - 운영계층 7계층(중요!)
* ip에 따라 트래픽이 나누면 같은 회사에서 오는 트래픽은 모두 하나의 ip로 생각함



## Tomcat은 세션을 어떻게 관리하고 있는가?

: Tomcat은 세션 클러스터링 방식으로 세션을 관리합니다. 세션 클러스터링은 여러 서버에 흩어져 있는 세션들을 하나의 그룹으로 묶어 동일한 세션으로 세션 관리를 하는 것입니다. 세션 클러스터링에는 몇 가지 방식이 있는데 그 중 Tomcat의 기본값은 all-to-all 세션 복제 방식입니다. 새로 세션이 생성되었거나 세션 정보가 변경될 때마다 Tomcat에서 세션을 제어하고 세션 복제를 처리하는 DeltaManager가 클러스터로 묶인 다른 모든 서버에 이와 동일한 세션 데이터를 복제합니다. 

- all-to-all 방식의 문제점?

  : 위와 같은 all-to-all 방식은 데이터가 변경될 때마다 세션 복제가 일어나기 때문에 서버의 수가 늘어날수록 메모리를 많이 사용하고 네트워크 트래픽도 증가한다는 문제가 발생합니다. 또한, DeltaManager는 클러스터에 묶인 모든 서버에 위와 같은 작업을 하기 때문에 웹 애플리케이션이 운영되고 있지 않은 서버에도 세션 데이터를 복제한다는 문제점도 가지고 있다. (가령, 통계 서버)

- Tomcat은 이러한 단점을 보완하기 위해 BackupManager라는 관리자를 제공합니다. BackupManager은 응용 프로그램이 배포된 하나의 백업 서버에만 세션 데이터를 복제하고 나머지 서버에는 Session ID 값만 복제하여 전달합니다. 

- 세션 복제 방식 자체는 서비스를 이용하는 사용자가 늘어날수록 세션을 복제하는 횟수와 복제해야 하는 세션 데이터의 양이 증가하기 때문에 이에 대한 과부하가 발생할 수도 있다는 것이다. 아무리 BackupManager를 사용하여 세션을 복제하는 서버의 수를 줄였다고는 하나 Session ID 값만 전달받는 서버의 경우, 결국Session ID 값이 저장되어 있는 서버에 요청해서 온전한 세션 데이터를 받아와야 하기 때문에 이에 대한 트래픽이 발생할수 밖에 없습니다.

### Tomcat 클러스터링은 언제 사용하면 좋은가?



## 블로그 글이 아닌 도큐먼트를 참고하는 이유는 무엇인가?

: 도큐먼트의 일부만 발췌하거나 자신이 필요한 부분에 해서만 쓰기 때문에 굉장히 협소한 관점에서 바라볼 수 밖에 없기 때문입니다. 또한, 작성자가 어떤 소스를 참고해서 썼는지 알 수 없습니다. 만약 작성자가 공식 도큐먼트가 아닌 다른 사람의 글을 참고해서 썼다면 2차 가공, 3차 가공을 거치면서 처음 공식문서의 의도와 달라질 수 있습니다.

- 그럼 블로그 글을 보면서 공부하면 안되는건가?

  : 맹신하지는 않되 참고용으로 쓰는데 하나의 개념을 다른 관점에서는 어떻게 보는지, 다양한 프로젝트에서 어떻게 활용될 수 있는지 참고하는 방향이 적절하다고 생각합니다.



## Redis를 세션 스토리지로 선택한 이유는 무엇인가?

: Redis는 장애 발생시 이로 인한 영향을 최소화하는데 강점을 가지고 있다. 그 중 하나로 Redis는 디스크에 데이터를 저장하여 데이터를 지속적으로 보존할 수 있다는 점이다. 디스크에 데이터를 기록하는 방법은 스냅샷과 AOF, 두 가지가 있다. 스냅샷은 사용자가 설정한 특정 시간 조건을 만족할 때 메모리상에 저장되어 있는 모든 데이터에 대해서 복사본을 만들어 저장되는 파일이다. 스냅샷에 저장된 Key-Value들을 읽어 메모리에 저장하는 방식으로 복구 작업이 진행된다. 반면 AOF 파일은 Redis가 수신한 명령 중 메모리 내부 데이터에 수정이 이루어진 명령이 기록된 파일이다. AOF 파일에 기록된 로그를 순차적으로 읽으면서 초기화된 데이터베이스에 명령어를 재실행하는 방법으로 복구 작업이 수행된다. 이러한 옵션들은 서버 오류로 인해 강제로 종료되더라도 데이터 손실없이 다시 복구시킬 수 있다. 그러나 디스크에 기록하는 연산을 추가로 수행해야하기 때문에 성능이 저하되는 요인이 될 수 있다.

다른 하나는 Redis가 Replication을 지원한다는 점이다. 마스터 / 슬레이브 Replication을 설정하면 마스터로부터 전체 데이터베이스의 초기 복사본을 받게 된다. 마스터에서 쓰기 작업이 수행되면 스냅샷과 쓰기 명령 로그를 마스터와 연결된 모든 슬레이브로 전송하고 슬레이브는 기존의 데이터를 지우고 전송된 덤프 파일을 로드한다. 이와 같은 복제 프로세스를통해 마스터와 슬레이브 간 데이터를 실시간으로 동기화할 수 있다. 문제가 발생하여 이에 대한 처리를 해야하거나 혹은읽기 전용 서버를 두어야 하는 등의 상황에서 마스터 / 슬레이브 Replication을 설정하면 읽기 성능과 가용성을 향상시킬수 있다.



Redis와 Memcached의 성능 차이는 미미하다. 두 가지 모두 각자 장단점이 있기 때문에 단순히 이게 무조건 더 좋다라고할 수 없으며 자신이 개발하고 있는 상황을 고려하여 더 적합한 인메모리 데이터베이스를 선택해야한다. 내가 진행하고 있는 sns 개발 프로젝트와 이에 대한 개발 환경을 고려하였을 때 다음과 같은 이유로 Redis를 선택했다. 

1. Redis가 Memcached에 비해 다양한 기능을 제공한다.

   : 애초에 Redis는 Memcached의 단점을 개선하여 만들어진 데이터베이스이다. 그렇기 때문에 Memcached에 비해 어플리케이션 운영에서 유용하게 쓰일 수 있는 편리한 기능들을 많이 제공한다. 특히, 이전 글에서 언급한 것처럼 SNS는 서비스가 중단되면 타격이 크기 때문에 자체 솔루션으로 쉽게 복구가 가능한 Redis를 사용하는 것이 유리하다고 생각한다.

2. Spring Boot에서 Redis를 위한 API를 지원한다.

   : 현재 내가 진행하고 있는 프로젝트는 Spring Boot 프레임워크 위에서 개발하고 있다. Spring Boot에서는 Redis API를 지원하기 때문에 아무래도 Memcached를 사용하는 것보다는 Redis를 사용하는 것이 편리하게 개발할 수 있고 이에 따른 유지 보수성도 좋아질 것으로 생각한다.



- Memcached는 데이터 복구 방법이 아예 없을까?



## 스프링 프로젝트에서 Redis를 사용할 때 lettuce를 선택했던데 그 이유는?

: jedis vs lettuce



## 캐시란 무엇인가?

: 캐시 히트율 ~~

* 캐시를 사용했을 때 장점

  : api가 유료면 해당 api를 찌르는거에 캐싱을 걸어서 요금이 덜 나가게끔 할 수도 있다.

* 캐시 히트율이 높을수록 좋은거면 100%를 달성하면 가장 좋은 것인가?

* 캐시 히트율에 영향을 미치는 요소 - 만료시간 / 캐시 크기

* 캐시 evict 어노테이션을 이용해서 꼭 명시적으로 해제해야 하나? - 상황에 따라서 다르다 / 트레이드 오프를 고려해야 된다 (최신데이터가 아닐 경우 미치는 )



## LRU 알고리즘과 LFU 알고리즘의 차이점?

* 이를 적용하면서 어떤 설정값을 튜닝했는가?



## 세션 저장소와 캐시 저장소를 분리한 이유가 무엇인가?



## 어떻게 MySQL Replication 구성하고 쿼리 요청에 따라 나눴나?

* AbstractRoutingDataSource에 대해서 설명



## CI / CD를 적용한 이유가 무엇인가?

- CI/CD를 사용하는 이유를 개발관점에서 말고 다른 관점에서도 설명해야 함

  : 배포하기가 어려우면 사용자 피드백에 따라서 빠르게 서비스를 배포하지 못한다.