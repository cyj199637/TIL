# 04. Algorithm

## DFS vs BFS?

### DFS

현재 정점과 연결된 정점들을 하나씩 갈 수 있는지 검사하고, 특정 정점으로 갈 수 있다면 그 정점에 가서 같은 행위 반복

→ 시작점에서 한 갈래로 더 이상 갈 수 없을 때까지 탐색하고, 더 갈 곳이 없다면 이전의 경로로 되돌아감

* 같은 정점을 다시 방문하지 않도록 정점에 방문했다는 것을 표시
* 재귀 함수를 통해 구현

<장점>

* 가장 직관적이고 구현하기 쉬운 탐색 방법

<단점>

* 재귀함수를 호출하기 때문에 함수 호출 비용이 추가로 들어감
* 재귀 깊이가 지나치게 깊어지면, 메모리 비용을 예측하기 어려움
  * 예를 들어, 그래프가 균등하게 분배되어 있는게 아니라 하나의 경로에 1000개의 정점, 10000개의 정점 ... 이 이어질 수 있다. 그렇다면 재귀가 1000번, 10000번이 호출되고 그만큼 메모리에 스택이 쌓이기 때문에 메모리 비용이 예측하기 어렵다. 같은 이유로 데이터 크기가 일정 크기 이상이라면 DFS를 권장하지 않는다.
* 최단 경로를 알 수 없음

### BFS

시작점에서 가까운 정점부터 순서대로 방문하는 탐색 알고리즘

→ 출발점을 먼저 큐에 넣고 시작 → 큐에 저장된 정점을 Dequeue하고, 해당 정점과 연결된 모든 정점을 큐에 저장

→ 정점마다 해당 로직 반복 → 큐에 저장된 정점이 없다면 반복 종료

* 큐를 이용하여 구현

<장점>

* 효율적인 운영이 가능하고, 시간/공간 복잡도 면에서 안정적
* 간선의 비용이 모두 같을 경우, 최단 경로를 구할 수 있음
  * 간선의 비용이 다르다면 구한 경로가 효율적인지 알 수 없음(최단거리 알고리즘을 사용해야 함)

<단점>

* DFS에 비해 코드 쿠현이 어려움
* 모든 지점을 탐색할 경우에 대비해, 큐의 메모리에 미리 준비되어 있어야 함