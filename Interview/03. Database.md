# 03. Database

(볼드체로 표시한 부분도 답변 준비할 것)

## 인덱스가 무엇인가?

https://jeong-pro.tistory.com/114?category=793347

<필요한 이유>

<구조와 원리>

인덱스는 보통 B-Tree 구조로 이루어져 있다. MySQL은 인덱스를 레코드 단위가 아니라 페이지 단위로 저장한다.

<인덱스를 사용하는 것이 무조건 좋은가?>

인덱스는 조회 작업(특히, 조건이 있는 조회 작업)에서는 효율적이지만 삽입, 변경, 삭제 작업에서는 성능이 떨어진다. 그 이유는 인덱스는 항상 정렬되어야 하기 때문이다. 따라서, 변경 작업이 일어날 때마다 인덱스 정렬 작업도 함께 일어나며, 변경 작업을 테이블과 인덱스 양쪽에서 수행해야 한다. **INSERT 작업 시**에는 해당 인덱스가 들어가야 하는 페이지의 공간이 없을 수도 있다. 그러면 리프 노드의 페이지 분리 작업이 일어나고 경우에 따라 분리 작업이 브랜치 노드까지 전파될 수 있기 때문에 성능이 느려진다. **DELETE 작업 시**에는 인덱스가 바로 삭제되는게 아니라 해당 인덱스에 '사용 안 함' 표시를 하기 때문에 공간 낭비가 발생한다. **UPDATE 작업 시**에는 인덱스 값을 변경하는 것이 아닌, 해당 인덱스를 삭제하고 새로 만들어주기 때문에 부하가 발생한다.

<인덱스 컬럼 설정 기준>

Cardinality(기수성)가 높은 컬럼 → 해당 컬럼이 각각의 레코드를 얼마나 잘 식별할 수 있는가



## 외래키를 쓸 때 어떤 점에서 좋고 어떤 점에서 안 좋은가?

외래키는 데이터의 (참조) 무결성을 보장해준다. 예를 들어, A 테이블의 code 컬럼은 B 테이블에 있는 값만 사용해야 하는 상황이라고 가정하자. 그런데 다양한 이유로 B 테이블에는 없는 값이 A 테이블의 code 컬럼에 있을 수 있다. 이렇게 참조 무결성이 깨지는 문제를 외래키를 생성하여 DBMS 차원에서 막아준다.

그러나 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하여 잠금이 여러 테이블로 전파되고 그로 인해 **데드락**이 발생할 때가 많다. 또한 상당한 디스크 IO를 유발한다.



## 트랜잭션?

여러 작업을 논리적으로 하나의 단위로 묶어주는 것. 하나의 트랜잭션은 커밋(모든 작업이 성공하여 DB에 반영)되거나 롤백(작업 하나라도 실패하여 시작하기 전 상태로 되돌아감)된다.

### 트랜잭션 성질(ACID)?

* A(원자성): 트랜잭션은 모두 DB에 반영되거나, 전혀 반영되지 않아야 한다.

  → 완료되지 않는 트랜잭션의 중간 상태를 DB에 반영시키지 않아야 한다.

* C(일관성): 트랜잭션의 작업처리결과는 항상 일관되어야 한다.

  → DB는 항상 일관된 상태를 유지해야 한다.

* I(격리성): 둘 이상의 트랜잭션이 동시에 수행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션의 연산에 끼어들 수 없다.

  → 각각의 트랜잭션은 독립적으로 이루어져야 한다.

* D(지속성): 트랜잭션이 성공한다면 해당 결과는 DB에 영구적으로 반영되어야 한다.



## 트랜잭션의 격리 수준에 대해서 설명해 보시오.

트랜잭션의 격리 수준이란 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 격리 수준이 높을수록 트랜잭션 간의 데이터 격리 정도가 높아지며, **동시성은 떨어지는 것이 일반적**이다.

1. `READ UNCOMMITED`

   : 각 트랜잭션에서의 변경 내용이 커밋이나 롤백 여부와 상관없이 다른 트랜잭션에서 보여진다. `Dirty Read` 현상이 발생한다.

   * `Dirty Read` : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랙잭션에서 볼 수 있는 현상

     ex) A가 테이블에 데이터를 INSERT하는 상황이다. 아직 커밋되지 않은 상황이지만 다른 사용자 B가 같은 테이블을 읽는다면 해당 데이터를 조회할 수 있다. 만약 INSERT 도중 문제가 생겨 롤백해버린다 해도 B는 여전히 해당 데이터를 정상적인 데이터로 처리하기 때문에 문제가 발생할 수 있다.

2. `READ COMMITED`

   : 어떤 트랜잭션에서 데이터를 변경해도 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. `Dirty Read` 현상은 발생하지 않지만 `Non-Repeatable Read` 현상이 발생한다.

   * `Dirty Read` X : ex) A가 테이블에 데이터를 INSERT하는 상황이다. INSERT한 데이터는 바로 테이블에 반영되고 이전 데이터는 **언두 영역**으로 백업된다. 아직 커밋되지 않은 상황이지만 다른 사용자 B가 같은 테이블을 읽는다면 언두 영역에 백업된 데이터를 조회한다.

   * `Non-Repeatable Read` : 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행해도 다른 결과를 가져오는 현상

     ex) B가 테이블을 조회할 때는 name이 C인 데이터가 없었다. B의 트랜잭션이 끝나지 않은 상황에서 A가 테이블에 어떤 데이터의 name을 C로 변경하고 커밋한다. 이후 B가 같은 쿼리로 조회하면 name이 C인 데이터가 조회된다.

3. `REPEATABLE READ`

   : MySQL의 **InnoDB 스토리지 엔진**에서 기본적으로 사용되는 격리 수준이다. `Dirty Read` 현상과`Non-Repeatable Read` 현상은 발생하지 않지만 `Phantom Read` 현상이 발생한다.

   * `Non-Repeatable Read` X : **MVCC**를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다. 이를 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호의 구간 내에서 백업된 언두 영역 데이터를 삭제되지 않는다.

     ex) 트랜잭션 번호가 10인 B가 테이블을 조회할 때는 name이 C인 데이터가 없다. B의 트랜잭션이 끝나지 않은 상황에서 A(트랜잭션 번호 12)가 테이블에 어떤 데이터의 name을 C로 변경하고 커밋한다. 그러나 B는 트랜잭션 번호를 받은 이후부터 번호가 10보다 작은 트랜잭션 번호에서 변경된 데이터만 본다.

   * `Phantom Read` : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상

     `SELECT ... FOR UPDATE` 나 `SELECT ... LOCK IN SHARE MODE` 등은 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져오게 된다.

4. `SELIALIZABLE`

   : 모든 데이터 부정합 문제가 발생하지 않는 격리 수준이다. 그러나 읽기 작업도 **읽기 잠금**을 획득해야만 하며, 동시에 다른 트랜잭션은 해당 레코드를 변경하지 못한다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 사용할 수 없다. (MySQL의 InnoDB 스토리지 엔진에서는 3단계에서도 `Phantom Read` 가 발생하지 않기 때문에 이 단계를 사용하지 않아도 된다.)

### 왜 격리 수준이 높아질 수록 동시성이 떨어지는가?

데이터의 정합성을 보장하기 위해 락으로 동시성을 제어하기 때문이다. 락을 사용하면 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있다.



## 락(Lock)?

데이터베이스의 일관성과 무결성을 유지하기 위해 트랜잭션의 순차적 진행을 보장할 수 있는 직렬화 장치이다. Lock이 필요한 이유는 동시에 같은 데이터에 접근하여 수정하려 할 때 데이터베이스의 일관성이 깨질 수 있기 때문이다. 따라서, 이와 같은 문제를 방지하기 위해 Lock을 걸고 관리하는 것을 **Locking**이라고 한다.



## Optimistic Lock vs Pessimistic Lock

* Optimistic Lock: 기본적으로 데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 보고, 우선적으로 락을 걸지 						  않는다.

  * 버전을 통해 관리

  * ex) 테이블 T에 대하여 커넥션 A와 B가 작업을 하기 위해 데이터를 가져온다. (테이블 T 버전 = 1)

     → A에서 T에 대해 수정 작업을 한다. (테이블 T 버전 = 2)

     → B도 T에 대해 수정 작업을 하려하지만 처음 가져온 버전과 현재 버전이 다르므로 충돌 발생

  * 데드락의 가능성이 적으며 성능의 이점

  * 충돌이 발생하면 해당 트랜잭션 버전의 이전 버전 모두가 롤백되기 때문에 오버헤드가 발생

* Pessimistic Lock: 기본적으로 데이터 갱신시 충돌이 발생할 것이라고 비관적으로 보고, (조회할 때 부터) 우선적으로 						    락을 건다.

  * 데이터를 가져올 때 DB 자체에 락을 건다.

  * ex) 테이블 T에 대하여 커넥션 A가 작업을 하기 위해 데이터를 가져온다. (테이블 T에 락이 걸림)

     → 커넥션 B가 테이블 B를 조회하려고 하면 예외 발생

  * 충돌에 대한 오버헤드가 줄어들며, 무결성을 지키는데 용이

  * 데이터에 락을 잡고 있는 것 자체가 비용이기 때문에 충돌이 없으면 오버헤드가 발생

* 언제 사용해야 하는가?

  * 충돌이 자주 발생하는 상황인가?
  * 읽기와 수정하기의 비율이 어느 정도인가?
  * 보통 웹 어플리케이션은 Optimistic Lock을 자주 사용



## Exclusive Lock vs Shared Lock?

https://jeong-pro.tistory.com/94?category=793347

* Exclusive Lock: 다른 사용자가 읽기, 수정, 삭제 모두를 불가능하게 함
* Shared Lock: 다른 사용자가 동시에 읽을 수는 있지만, Update Delete를 방지함



## 교착 상태(Deadlock)?

프로세스나 스레드가 결코 일어날 수 없는 특정 이벤트를 기다리는 상태

ex) 공유 자원 R1과 R2가 있고, 커넥션 A와 B가 각각 맡은 작업을 수행하기 위해 R1과 R2를 점유하고 있는 상태이다. A와 B는 작업을 마치려면 R1과 R2가 모두 필요하기 때문에 각자 가지고 있는 자원을 점유한 상태에서 서로 다른 커넥션이 가지고 있는 자원을 대기하는 상태

<필요 조건>

1.  상호 배제 조건: 여러 프로세스가 동시에 한 자원에 접근하지 못함

   ​					  → 한 번에 한 프로세스만 해당 자원을 가질 수 있음

2. 점유와 대기 조건: 한 프로세스가 자원을 점유한 상태로 다른 자원을 점유하기 위해 대기

3. 비선점 조건: 프로세스에서 자원을 할당받으면 작업을 완료할 때까지 시스템에서 프로세스의 자원을 뺏을 수 없음

4. 순환 대기 조건: 점유와 대기를 하는 상태로 순환 사이클에 갇혀 빠져나올 수 없는 상태

<해결법>

1. 교착 상태 무시: 교착 상태가 드물게 발생하는 시스템(ex. OS)에서 사용하는 방법

   → 교착 상태가 드물게 발생하므로 교착 상태 해결에 대한 비용을 지불하는 것이 효율적이지 못하다고 생각해서 교착 상태가 일어나지 않는다고 가정하고 이를 무시.

   → 만약 교착 상태가 발생하면 사용자가 프로세스를 죽이거나 시스템을 재부팅하는 방법으로 해결

2. 교착 상태 탐지 및 복구: 교착 상태가 자주 발생하는 시스템에서 사용하는 방법

   * 탐지: 순환 대기 존재 여부에 초점을 맞춰 탐지 알고리즘을 호출

   * 복수: 탐지에서 찾아낸 순환 대기를 깨서 교착 상태로부터 회복

     * 순환 대기가 깨질 때까지 프로세스 종료 / 순환 대기에 포함된 제어권을 뺏어 롤백

       → 시스템마다 우선 순위에 따라 종료할 프로세스를 선정(MySQL은 트랙잭션 크기(작업 대상 레코드 수)가 가장 작은 순)

3. 교착 상태 예방: 교착 상태의 필요 조건이 발생하지 않도록 하여 교착 상태를 예방하는 방법

   → 교착 상태가 자주 발생하는 시스템에서 예방을 사용하지 않는 이유?

   → 교착 상태의 조건 중 하나를 거부하여 교착 상태가 발생하지 않는 환경을 만들어버리면 자원을 효율적으로 사용할 수 없기 때문

   → ex) 점유와 대기 조건을 거부한다면, 프로세스가 작업을 수행하기 전에 필요한 모든 자원을 요청하고 획득해야함

4. 교착 상태 회피: 교착 상태를 인정하고 피해가는 방법

   → 회피 알고리즘(ex. 은행원 알고리즘): 시스템을 안전 상태와 불안전 상태로 나누어 불안전 상태일 때는 대기시킴

   → 교착 상태가 자주 발생하는 시스템에서 회피를 사용하지 않는 이유?

   → 탐지와 복구는 교착 상태가 발생한 것 같을 때 탐지하고 복구하지만, 회피는 자원을 요청할 때마다 시스템의 상태를 판단하고 회피하므로 비효율적



## MySQL 성능이 나빠지면 어떻게 해야하는가?

: 여러 가지 중 하나는 슬로우 쿼리 로그를 본다. 모니터링을 통해 느린 쿼리가 나타나면 알림이 오도록 하게 한다.