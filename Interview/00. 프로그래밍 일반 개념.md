# 00. 프로그래밍 일반 개념

## OOP(객체 지향 프로그래밍)?

https://jeong-pro.tistory.com/95?category=793347



## 클래스/상태/메소드?

* 클래스: 현실 세계에 있는 것을 프로그래밍 언어로 표현한 것. 상태와 행동이 있어야 한다.
* 상태: 클래스의 특성을 결정짓는 것 → 변수
* 메소드: 어떠한 작업을 하고 그에 대한 결과를 돌려주는 것



## 클래스 vs 객체 vs 인스턴스?

* 객체: 세상에 존재하는 유일무이한 사물
  * 속성: 명사로 표현되는 특성 / 값을 가질 수 있음
  * 기능/행위(메서드): 동사로 표현되는 특성 / 수행 절차 또는 로직을 가질 수 있음
* 클래스: 분류, 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념
* 인스턴스: 클래스를 이용해 객체를 만들었다는 것을 강조하는 표현



## 객체 지향 원칙?

- 이를 어디에 적용해보았는가?

- 이 원칙을 적용하면 왜 재사용성이 높아지는가?

  : 어느 한 클래스에 종속되어있는 코드가 아니라 공통 기능에 초점을 맞춰 모든 클래스에 적용할 수 있는 코드를 작성할 수 있기 때문에 재사용성이 높아진다.

- 이 원칙을 적용하면 왜 유지보수성이 높아지는가?

  : 중복 코드가 제거되어 관리해야 할 코드가 줄어들기 때문



## 객체 지향의 4대 특성?

- 이를 어디에 적용해보았는가?

- 이 특성으로 인해 코드의 어떤 부분이 좋아지는가?

  - 캡슐화: 내가 작성한 의도를 파악할 수 있다. / 메소드를 내가 설계한 의도대로만 사용할 수 있게 된다. / 내가 사용하게 허용된 것만 다른 사람이 쓰게 할 수 있다. / 구체적인 코드가 혼재되어 있으면 해당 기능의 핵심 기능을 파악하기 어렵다.

- 그럼 무조건 추상화를 해야 좋은건가?

  : 로직에 대한 확장의 여지가 있냐 없냐에 따라 인터페이스 추상화 여부가 정해진다.



## Overloading vs Overriding?



## Call by Reference vs Call by Value?



## 동등성 vs 동일성?





## 동시성 vs 병렬성?

동시성 - 하나의 코어에서 여러 스레드를 돌아가면서 실행시키는 것

병렬성 - 여러 개의 코어에서 하나의 스레드씩 실행시키는 것



## 동기 - 비동기 vs 블로킹 - 논블로킹?

https://deveric.tistory.com/99



## 라이브러리 vs 프레임워크 vs API?

### API(Application Programming Interface)

: 응용 프로그램에서 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스

→ 소프트웨어를 조종하는 리모컨 같은 역할

* 인터페이스: 하나의 시스템을 구성하는 2개의 구성 요소가 상호 작용하기 위해서는 경계가 필요하다. 이 경계에서 각 구성요소가 상호 접속하기 위한 하드웨어, 소프트웨어, 조건, 규칙 등을 포괄적으로 가리키는 것
* 구현과 독립적으로 사양만 정의되어 있다.
* API에 따라 접근 권한이 있을 수 있다.

### 라이브러리

: 응용 프로그램 개발을 위해 필요한 기능을 모아 놓은 소프트웨어

* 모든 코드를 재사용할 수 없으므로 특정 기능에 대한 코드만이라도 재사용하기 위해 모아놓은 것
* 독립성을 가진다. → 하나의 라이브러리는 다른 라이브러리에 의존하지 않음
* **응용 프로그램이 능동적으로 라이브러리를 사용한다.** → 응용 프로그램이 필요할 때 라이브러리를 호출

### 프레임워크

: 응용 프로그램이나 소프트웨어의 솔루션 개발을 수월하게 하기 위해 제공된 소프트웨어 환경

* 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계

  * 코드를 재사용함으로써 설계 아이디어까지 재사용하는 것 → 비즈니스 로직에만 집중 가능
  * 코드를 통해 재사용할 수 있었던 이유: 프레임워크가 어플리케이션을 제어하기 때문 → **제어의 역전(DI)**
    * 객체의 생성, 관계 설정, 사용, 생명 주기 등 객체 간 상호작용을 프레임워크가 관장

* 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 어플리케이션의 골격

* **응용 프로그램이 수동적으로 프레임워크에 의해 사용된다.**

  ex) 스프링 프레임워크에서는 요청이 들어오면 DispatcherServlet이 요청을 처리할 HandlerAdapter를 선택하고 HandlerAdapter가 실행할 때 개발자가 구현한 컨트롤러 객체를 호출한다.

#### 프레임워크와 라이브러리가 생긴 이유

* 설계 재사용을 강조하는 디자인 패턴으로는 코드를 재사용할 수 없다.
* 코드를 재사용할 수 있는 컴포넌트 조립 방식은 실패했다.
  * 컴포넌트 조립 방식: 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 어플리케이								 션을 만드는 소프트웨어 개발 방법론. 컴포넌트를 기능별로 개발하여 각자 필요한 것을 골라 								 조립.
  * why? 현실 세계에 있는 도메인 영역은 굉장히 다양하고, 이 도메인들은 자기만의 특수성을 가지고 있기 때문에 최적화된 로직이 필요하다. 하지만 모든 도메인을 포괄할 수 있는 컴포넌트를 만들 수 없다.

#### API vs 라이브러리 vs 프레임워크

* API와 라이브러리의 차이점은 구현 로직의 유무이다.
* 라이브러리와 프레임워크의 차이점은 응용 프로그램의 흐름 주도권을 누가 가지고 있느냐이다.



## 로깅?

운영체제나 소프트웨어가 실행 중에 발생하는 이벤트를 기록하는 행위

<사용하는 이유>

* 서비스 동작 상태 파악, 장애 파악 & 알람

<방법>

* Linux System API call - syslog()
* 로깅 라이브러리 - slf4j

### slf4j?

로깅 추상화 라이브러리

* API - SpringBoot에서는 slf4j
  * 로깅 인터페이스
* Binding - Spring Boot Starter에서는 logback

  * 여러 Logger로 연결해주는 일을 함
  * slf4j API를 구현한 클래스에서 Binding으로 연결된 로거의 API를 호출
  * Binding은 한 개만 추가해야 함
* Bridge
  * 레거시를 위한 것
  * 로거 호출을 slf4j의 인터페이스로 연결
  * 해당 로거 호출을 대신 받아서 slf4j API를 호출함
  * Bridge는 여러 개를 넣어도 상관없음
  * Bridge와 Binder는 같은 종류를 쓰면 안됨

<로깅 레벨>

* FATAL: 매우 심각한 에러가 많은 경우, 이 레벨이 사용되면 프로그램이 종료되는 가능성이 높다.
* ERROR: 에러가 발생했지만, 프로그램이 종료되지 않음
  * 의도하지 않은 Exception이 발생하는 경우 사용
* WARN: 에러가 될 수 있는 잠재적 가능성이 많은 경우, 알람이 오도록 설정하여 에러가 나기 전 조치를 취하거나, 에러가 나면 그 전의 상황을 알 수 있다.
* INFO: 애플리케이션의 상태를 간결하게 보여주는 경우
  * 명확한 의도를 가진 Exception이나 로그들
* DEBUG: INFO 레벨보다 더 자세한 정보가 필요한 경우, 권한이 없어 디버깅이 불가능한 경우 유용
* TRACE: DEBUG 레벨보다 더 자세한 정보가 필요한 경우, 개발환경에서 버그를 해결하기 위해 사용
  * 최종 프로덕션이나 커밋에 포함되면 안된다.

<로깅 메시지>

* 독자를 고려하라

  → 로그 파일이 어떤 레이어를 거칠지 모르기 때문에 인코딩 문제를 최소화하기 위해 영어를 사용

* 로그 메시지에 컨텍스트를 담아라

  → 에러가 났을 때 에러 메시지만으로 상황을 파악할 수 있도록 작성하고, 가능하면 해결방법도 작성

<주의 사항>

* 로그 파일 / DB 생명 주기 & 용량
* 개인 정보
* 시스템 주요 정보(시스템 보안, 계정 정보)