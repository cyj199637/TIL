# 02. Spring

## Spring vs Django?

- Django Autentication이란?
- Django messages 프레임워크란?



## Spring vs Spring Boot?

https://ssoco.tistory.com/66

< Spring >

: 엔터프라이즈 애플리케이션을 보다 쉽게 만들 수 있게 도와준다는 목표를 가지고 있음

### 왜 스프링을 통해 기업용 애플리케이션을 보다 쉽게 만들 수 있는 것인가?

스프링의 DI, IoC를 통해 재사용 및 유지보수가 용이한 코드를 작성할 수 있고, 확장성을 가진 코드를 설계할 수 있다. 또한 스프링이 제공해주는 기능들을 통해 개발자는 비즈니스 로직에만 집중할 수 있기 때문에 생산성을 증가시킬 수 있다.

* 목표를 위한 해결책

  1. Dependency Injection(DI) - 의존성 주입

     : DI를 통해 객체간의 결합도를 낮춰 코드 재사용성을 높이고, 단위테스트를 용이하게 할 수 있도록 해준다.

  2. 중복된 코드 제거

     : 반복되는 코드를 제거함으로써 개발자가 비즈니스 로직에만 집중할 수 있도록 해준다.

  3. 다른 프레임워크와의 통합

     : JUnit, Mockito와 같은 다른 프레임워크(해당 기능에서의 최선의 방법으로 구현된 프레임워크나 모듈들)와 통합하여, 개발자가 비즈니스 로직외에 신경 써야 할 부분을 덜어준다 → 생산성 향상

< Spring Boot >

: 최소한의 설정으로 스프링 프레임워크와 서드파티 라이브러리를 사용 가능하게 해주고 이를 기반으로 응용 프로그램이나 서비스를 쉽게 만들 수 있도록 도와준다는 목표를 가지고 있음

* 목표를 위한 해결책
  1. Auto Configuration - 자동 설정
  2. 쉬운 의존성 관리
  3. 내장 서블릿 컨테이너(내장 서버)

### Spring Boot를 사용하는 이유를 IoC와 연결지어서 말해보시오.



## Servlet?

### Servlet

: 웹 어플리케이션을 만들 때 필요한 인터페이스

* Spring Web MVC가 Servlet을 사용

<Servlet이 생긴 이유>

* 기존 웹 서버는 정적인 데이터만 처리가 가능했기 때문에 사용자(요청)에 따라 다른 처리를 해줄 수 없었음

* 이를 개선하기 위해 CGI 등장

  * CGI: 동적 데이터를 처리하는 웹 서버와 프로그램 사이의 인터페이스(규약)

    * c, php, perl 등 다양한 언어로 구현할 수 있었기 때문에 구현체를 추상화하기 위해 등장

  * 문제점1: 요청이 들어올 때마다 프로세스가 생성됨 → 프로세스를 스레드로 교체

  * 문제점2: 같은 CGI 구현체를 사용하더라도 스레드 당 하나씩 CGI 구현체가 생성됨

    ​			   → CGI 구현체를 싱글톤으로 관리(= Servlet)

![Servlet](../images/Servlet.png)

* Web Container
  * Servlet을 관리하면 Servlet Container라고도 불림
  * 요청이 들어오면 스레드를 생성하고, Servlet을 실행시킴
  * Servlet 인터페이스에 따라 메소드를 호출하고 Servlet을 관리

<Servlet 인터페이스>

각 메소드는 Servlet 컨테이너(Tomcat)가 호출함

* Init: Servlet 인스턴스 생성
* Service: 실제 기능이 수행되는 곳
  * HTTP 메소드에 따라 개발자가 구현한 doXXX 메소드를 호출
* Destroy: Servlet 인스턴스 종료
  * 보통 컨테이너가 종료되는 시점에 호출됨
  * 특정 서블릿 로드 / 언로드 시에도 사용



## DispatcherServlet?

Spring Web MVC에서 사용하는 Servlet

* 다음의 서블릿 단점을 보완

  * 요청 url 하나 당 서블릿 하나를 만들어야 하고 서블릿이 만들어 질 때마다 web.xml에 여러 설정이 계속해서

    추가로 붙게 됨

  * 여러 서블릿에서 공통적으로 처리하고 싶은 부분에 대한 처리가 복잡함

* Front Controller 역할

  * 모든 요청을 받아서 각각의 요청을 처리할 핸들러들에게 분배(Dispatch)

<동작 순서>

1. 요청을 분석한다. (로케일, 테마, 멀티파트 등)

2. (HandlerMapping에게 위임하여) 아래 방법 중 하나로 요청을 처리할 핸들러(컨트롤러)를 찾는다.

   * BeanNameHandlerMapping: 빈 이름과 URL을 매핑하는 방식
   * ControllerClassNameHandlerMapping
   * SimpleUrlHandlerMapping
   * DefaultAnnotationHandlerMapping: 어노테이션(@RequestMapping)으로 URL과 매핑하는 방식

3. (등록되어 있는 HandlerAdapter 중에) 해당 핸들러를 실행할 수 있는 “HandlerAdapter”를 찾는다.

4. 찾아낸 “HandlerAdapter”를 사용해서 핸들러의 응답을 처리한다.

   * 핸들러의 리턴값을 보고 어떻게 처리할지 판단한다.

     * 뷰 이름에 해당하는 뷰를 찾아서 모델 데이터(= ModelAndView)를 렌더링한다.

       (핸들러에 @ResponseBody 애노테이션이 없이 문자열을 리턴할 때 리턴된 문자열을 뷰 이름으로 인식)

       * 렌더링: 정해진 규칙에 따라 HTML 문서를 분석해서 알맞은 화면을 생성하는 것

     * @ResponseEntity가 있다면 Converter를 사용해서 응답 본문을 만들고. → ModelAndView가 Null
     
       (핸들러가 @ResponseBody 애노테이션을 가진 채 문자열을 리턴하는 경우)

5. (부가적으로) 예외가 발생했다면, 예외 처리 핸들러에 요청 처리를 위임한다.

6. 최종적으로 응답을 보낸다.



## MVC 패턴?

https://jeong-pro.tistory.com/96?category=793347



## IoC vs DI?

IoC는 객체의 생성부터 소멸의 객체의 생명주기와 객체 간의 관계를 컨테이너 혹은 프레임워크가 개발자 대신 관리해주는 것

DI는 구체적인 의존 오브젝트와 클라이언트 오브젝트를 런타임 시에 연결해주는 것. 클라이언트 오브젝트 코드는 인터페이스에만 의존하고 있어야 하며 해당 인터페이스를 어떤 클래스로 구현할 것인가는 외부 즉, 제 3자가 정해주는 것. 그래서 DI를 사용하면 클라이언트 오브젝트의 코드 변경 없이 의존 오브젝트의 구현 방식을 쉽게 바꿀 수 있는 것이다.

### 외부에서 주입받으면 좋은 점?

1. 내부에서 생성하게 되면 의존 오브젝트의 인터페이스를 이용하여 클라이언트 코드를 작성해도 결국 개발자가 직접 의존 오브젝트의 클래스를 선택하기 때문에 결합점이 클라이언트 오브젝트 코드에 조금 남게 된다.
2. 싱글톤인지 다른 스코프로 생성할 건지에 대한 고민을 할 필요가 없다.



## AOP?

횡단 관심에 따라 프로그래밍하는 것

<필요한 이유>

1. 시간 측정, 권한 체크, 트랜잭션을 거는 등의 인프라 로직은 부가 기능이기 때문에 어플리케이션의 전 영역에 나타날 수 있음
2.  중복 코드를 만들어 낼 가능성이 높아 유지보수가 힘들어짐
3. 비즈니스 로직과 함께 있으면 비즈니스 로직을 이해하기 어려워짐

<용어>

* Target: 어떤 대상에 부가 기능을 부여할 것인가
* Advice: 어떤 부가 기능을 부여할 것인가 → Before, AfterReturning, After Throwing, After, Around
* Join point: 어디에 적용할 것인가 → 메서드, 필드, 객체, 생성자 등
  * Spring AOP는 메서드 레벨만 지원
* Pointcut: 실제 advice가 적용될 지점. Spring AOP에서는 advice가 적용될 메서드를 선정

<주의 사항>

* 자기가 자신의 메서드를 호출할 때는 AOP가 적용되지 않음

  → 타깃 오브젝트에서 실행한 메서드 내부에 있는 메서드기 때문에 AOP가 적용되지 않은 타깃 오브젝트의 메서드를 그대로 실행하게 됨



## 다이나믹 프록시?

먼저 클라이언트가 프록시 요청을 위해 프록시 팩토리에게 타깃 오브젝트의 인터페이스 정보를 넘겨준다. 그럼 프록시 팩토리를 해당 인터페이스를 구현한 다이내믹 프록시를 자동으로 생성한다. 부가기능은 리플렉션 API의 invoke() 메소드를 활용하여 부가기능을 InvocationHandler를 구현한 오브젝트에 담는다. 다이내믹 프록시는 클라이언트로 받는 모든 요청을 InvocationHandler에게 전달하고 InvocationHandler는 타깃 오브젝트의 메소드를 호출하여 핵심 기능 동작을 위임한다. invoke() 메소드 덕분에 부가기능 코드가 중복되는 걸 막아주고, 타깃의 종류와 상관없이 재사용이 가능하다.

- aspect J

### 위빙

: Aspect 클래스에 정의한 Advice 로직을 타깃(Target)에 적용하는 것

1. 컴파일(CTW)

* A.java ----(AOP)---> A.class ([AspectJ](https://www.eclipse.org/aspectj/))
* A를 컴파일할 때, 중간에 공통된 코드를 끼어넣어 컴파일된 코드에는 해당 코드가 생김
* 로드 타임, 런타임에 별다른 성능 부하가 없음
* 별도의 컴파일 과정을 거쳐야 함

2. 바이트코드 조작(LTW)

* A.java -> A.class ---(AOP)---> 메모리 (AspectJ)

* 컴파일된 클래스를 JVM에 로딩하는 시점에 바이트 코드 조작을 통해 공통된 코드를 끼어넣어 메모리에 올라온

  클래스에는 해당 코드가 생김

* 클래스 로딩할 때 약간의 부하가 생길 수 있음

* 로드 타임 위버 설정이 들어가야 함

3. 런타임(RTW)

* Spring AOP에서 사용하는 위빙 방식
* 부가 기능을 제공하는 Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행 → 프록시 패턴
* 실제 런타임 상, Method 호출 시에 위빙이 이루어 짐
* 소스파일, 클래스 파일에 대한 변형이 없다는 장점
* 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어지고, 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.



## filter vs interceptor?



## 스프링 프로젝트에서 메모리 누수가 일어나는 경우는 어떤 경우인가?

wrapper 클래스의 사용으로 오토박싱된 메모리가 해제 되지 않는 현상

캐쉬로 객체를 사용하고 해제 하지 않는 경우

자료구조를 생성하면서 제대로 처리하지 않는 경우



## 왜 (단위)테스트를 작성해야 하는가?

테스트는 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 작성한 코드를 확신할 수 있게 해준다. 코드나 적용한 기술이 변경되더라도 변경하기 이전과 동일한 기능을 잘 수행한다는 것을 보장해준다. 또한 새로운 기능을 추가함으로써 기존 기능들이 영향을 받지 않고 잘 동작하는지도 확인할 수 있다.

테스트의 결과가 원하는 대로 나오지 않으면 코드나 설계에 결함이 있다는 것을 바로 알 수 있으므로 빠르게 오류를 제거할 수 있다. 테스트를 통과한 기능은 정상적으로 동작한다는 것이 보장되기 때문에 구현된 코드에 대한 확신을 가지고 다른 기능을 개발할 수 있어 전체적인 개발 속도가 빨라질 수 있다.

기능마다 테스트 케이스를 꼼꼼하게 작성하면 발생 가능한 예외 상황이나 다른 클래스에 끼치는 영향 등을 다시 고려하지 않고 코드를 수정할 수 있어 유지보수성을 높일 수 있다.

단위 테스트로 테스트를 진행하지 않으면 하나의 기능을 테스트할 때 그와 관련된 모든 계층의 기능이 다 만들어져 있어야 한다. 또한, 테스트에 실패하면 테스트에 참여하는 클래스가 많아 원인을 찾기가 힘들다. 이런 경우 테스트를 준비하기도 힘들고 환경이 조금이라도 달라지면 결과가 동일하지 않을 수 있다.

단위 테스트를 충분히 거쳤다면 여러 클래스나 외부 시스템과의 통합 테스트를 진행할 때 오류가 발생할 확률도 줄어들고 발생하더라도 쉽게 처리할 수 있다.

단위 테스트로 개발자가 만든 코드가 원래 의도한 대로 동작하는지를 스스로 빨리 확인할 수 있다.



## 단위테스트를 작성할 때 주의해야 할 점은 무엇인가?

테스트 대상의 단위가 너무 크지 않아야 한다. 작을수록 테스트 코드를 이해하기 쉽고 작성하기도 쉽다. 논리적인 오류가 발생하여 결과가 바르게 나오지 않으면 원인을 찾기가 어려워진다. 작은 단위로 테스트를 진행하면 나중에 코드가 많아져도 작은 단위 테스트로 검증한 부분은 제외하고 접근할 수 있다.

코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. 외부 환경에 영향을 받지 않아야 하며, 테스트 실행 순서를 바꿔도 동일한 결과가 보장되어야 한다. 따라서, 테스트가 적절히 격리되어야 한다.

성공하는 테스트 뿐 아니라 네거티브 테스트도 만들어야 한다. 

기능 별로 최대한 자세한 시나리오에 따른 테스트를 작성해야 한다. 어떤 입력 값이 필요한지, 기대에 벗어나는 행동을 할 때 어떤 예외를 던지는지 등 다양한 시나리오에 대한 테스트를 작성한다면 테스트 자체만으로도 해당 기능의 명세서 역할을 할 수 있다. 이를 바탕으로 다른 사람들이 코드를 보고 이해하는데 도움을 줄 수 있고, 코드의 활용성을 높일 수 있다.

테스트 대상과 연결된 의존관계를 모두 차단하고 필요에 다라 이를 목 오브젝트로 대체하여 고립된 환경을 만든다. 이렇게 작성하면 테스트 작성도 간단하고 실행 속도도 빠르며, 외부 환경이 테스트 결과에 영향을 미치지 않는다.



## @Transactional 의 propagation 속성에 대해서 설명해 보시오.

https://deveric.tistory.com/86

트랜잭션의 동작방식을 제어할 수 있는 여러 속성들이 있는데 그 중에 하나가 `propagation` 이다. `Transaction propagation` 이란 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 있을 때 어떻게 동작할 것인가를 결정하는 방식이다.

* 트랜잭션 경계: 트랜잭션 시작 ~ `commit()` / `rollback()` 까지의 구간

<옵션 종류>

1. `PROPAGATION_REQUIRED`

   : 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다. 기본 트랜잭션 전파 속성. 진행 중인 트랜잭션에 참여하는 경우, 트랜잭션 경계의 끝에서 트랜잭션을 커밋시키지 않고, 최초 트랜잭션이 정상적으로 진행되야 커밋될 수 있다.

2. `PROPAGATION_REQUIRES_NEW`

   : 항상 새로운 트랜잭션을 시작한다. 진행 중인 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작한다. 독립적인 트랜잭션이 보장돼야 하는 코드에 적용한다.

3. `PROPAGATION_NOT_SUPPORTED`

   : 트랜잭션 없이 동작한다. 진행 중인 트랜잭션이 있어도 이를 무시한다. 트랜잭션에 참여하는 메소드가 많은 상황에서 특정 메소드만 트랜잭션 적용에서 제외할 때 유용하다.



## Maven?

라이브러리를 관리해주는 도구

* 라이브러리 관리 기능: pom.xml에 사용할 라이브러리 이름과 버전만 명시하면 해당 라이브러리를 자동으로 내려받고 관리해준다.
* 빌드 기능: 애플리케이션을 빌드하는 표준화된 방법 제공



## JDBC?

: JAVA 진영의 DB 연결 표준 인터페이스

* JDBC API를 JDBC DriverManager가 구현하며, JDBC DriverManager는 DB 종류에 따라 내부 로직이 다름
* JDBC DriverManager → Connection 객체 → (Connection으로) Statement 획득 → (Statement로) ResultSet 획득

<단점>

* 쿼리 별로 중복되는 코드가 많음
* 쿼리를 일일히 작성해야 함
* Connection 관리를 계속해서 해야 함

### Connection Pool?



## SQL Mapper?

: 객체와 SQL을 매핑하는 것

* SQL과 매핑할 객체만 지정한다면 JDBC API 사용과 응답 결과를 객체로 매핑하는 일을 대신 처리

< Spring JDBC >

Spring JDBC(ex. JDBCTemplate)는 SQL Mapper 역할을 하며, 기존 JDBC를 한 단계 더 추상화시킴

* DB와의 연결을 위한 설정 정보가 담긴 DataSource를 주입
* 개발자는 실행할 쿼리, 파라미터 값 등을 넘겨주면 Spring JDBC가 위의 과정이나 모든 예외 처리, 트랜잭션 제어 등 많은 작업을 대신 처리해줌

< MyBatis >

* SQL을 자바에서 XML로 분리하려는 시도
  * 복잡한 JDBC 코드가 제거됨
  * ResultSet과 같이 결과값을 매핑하는 객체가 없음
  * 간단한 설정
  * 관심사의 분리

<동작 순서>

1. SqlSessionFactoryBuilder가 MyBatis 설정 파일을 읽어 SqlSessionFactory 생성
2. SqlSessionFactory가 SqlSession을 생성
3. 어플리케이션은 Mapper 인터페이스에 대한 매핑을 SqlSession에 요청
4. SqlSession은 각 Mapper 인터페이스에 맞는 Mapper 인스턴스를 생성하여 매핑
5. Mapper 인터페이스의 메소드가 호출되면 매핑된 SQL 구문 실행



## MyBatis vs JPA?

마이바티스나 스프링 JdbcTemplate은 보통 SQL 매퍼라고 한다. SQL 매퍼는 객체와 SQL을 매핑하는 것으로 SQL과 매핑할 객체만 지정한다면 JDBC API 사용과 응답 결과를 객체로 매핑하는 일을 대신 처리해준다. 이런 점에서 어느 정도 불편한 점을 없애주지만 결국 개발자가 SQL을 직접 작성하므로 SQL에 의존하는 개발을 하게 되고 **패러다임 불일치 문제**가 발생한다. 반면 JPA는 SQL 작성도 ORM 프레임워크가 담당하기 때문에 위의 문제점이 없어진다.