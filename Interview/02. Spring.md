# 02. Spring

## Spring vs Django?

- Django Autentication이란?
- Django messages 프레임워크란?



## Spring vs Spring Boot?

- Spring의 장점



## MVC 패턴?

https://jeong-pro.tistory.com/96?category=793347



## IoC vs DI?

IoC는 객체의 생성부터 소멸의 객체의 생명주기와 객체 간의 관계를 컨테이너 혹은 프레임워크가 개발자 대신 관리해주는 것

DI는 구체적인 의존 오브젝트와 클라이언트 오브젝트를 런타임 시에 연결해주는 것. 클라이언트 오브젝트 코드는 인터페이스에만 의존하고 있어야 하며 해당 인터페이스를 어떤 클래스로 구현할 것인가는 외부 즉, 제 3자가 정해주는 것. 그래서 DI를 사용하면 클라이언트 오브젝트의 코드 변경 없이 의존 오브젝트의 구현 방식을 쉽게 바꿀 수 있는 것이다.

### 외부에서 주입받으면 좋은 점?

1. 내부에서 생성하게 되면 의존 오브젝트의 인터페이스를 이용하여 클라이언트 코드를 작성해도 결국 개발자가 직접 의존 오브젝트의 클래스를 선택하기 때문에 결합점이 클라이언트 오브젝트 코드에 조금 남게 된다.
2. 싱글톤인지 다른 스코프로 생성할 건지에 대한 고민을 할 필요가 없다.



## AOP?

횡단 관심에 따라 프로그래밍하는 것

<필요한 이유>

1. 시간 측정, 권한 체크, 트랜잭션을 거는 등의 인프라 로직은 부가 기능이기 때문에 어플리케이션의 전 영역에 나타날 수 있음
2.  중복 코드를 만들어 낼 가능성이 높아 유지보수가 힘들어짐
3. 비즈니스 로직과 함께 있으면 비즈니스 로직을 이해하기 어려워짐

<용어>

* Target: 어떤 대상에 부가 기능을 부여할 것인가
* Advice: 어떤 부가 기능을 부여할 것인가 → Before, AfterReturning, After Throwing, After, Around
* Join point: 어디에 적용할 것인가 → 메서드, 필드, 객체, 생성자 등
  * Spring AOP는 메서드 레벨만 지원
* Pointcut: 실제 advice가 적용될 지점. Spring AOP에서는 advice가 적용될 메서드를 선정

<주의 사항>

* 자기가 자신의 메서드를 호출할 때는 AOP가 적용되지 않음

  → 타깃 오브젝트에서 실행한 메서드 내부에 있는 메서드기 때문에 AOP가 적용되지 않은 타깃 오브젝트의 메서드를 그대로 실행하게 됨



## 다이나믹 프록시?

먼저 클라이언트가 프록시 요청을 위해 프록시 팩토리에게 타깃 오브젝트의 인터페이스 정보를 넘겨준다. 그럼 프록시 팩토리를 해당 인터페이스를 구현한 다이내믹 프록시를 자동으로 생성한다. 부가기능은 리플렉션 API의 invoke() 메소드를 활용하여 부가기능을 InvocationHandler를 구현한 오브젝트에 담는다. 다이내믹 프록시는 클라이언트로 받는 모든 요청을 InvocationHandler에게 전달하고 InvocationHandler는 타깃 오브젝트의 메소드를 호출하여 핵심 기능 동작을 위임한다. invoke() 메소드 덕분에 부가기능 코드가 중복되는 걸 막아주고, 타깃의 종류와 상관없이 재사용이 가능하다.

- aspect J

### 위빙

: Aspect 클래스에 정의한 Advice 로직을 타깃(Target)에 적용하는 것

1. 컴파일(CTW)

* A.java ----(AOP)---> A.class ([AspectJ](https://www.eclipse.org/aspectj/))
* A를 컴파일할 때, 중간에 공통된 코드를 끼어넣어 컴파일된 코드에는 해당 코드가 생김
* 로드 타임, 런타임에 별다른 성능 부하가 없음
* 별도의 컴파일 과정을 거쳐야 함

2. 바이트코드 조작(LTW)

* A.java -> A.class ---(AOP)---> 메모리 (AspectJ)

* 컴파일된 클래스를 JVM에 로딩하는 시점에 바이트 코드 조작을 통해 공통된 코드를 끼어넣어 메모리에 올라온

  클래스에는 해당 코드가 생김

* 클래스 로딩할 때 약간의 부하가 생길 수 있음

* 로드 타임 위버 설정이 들어가야 함

3. 런타임(RTW)

* Spring AOP에서 사용하는 위빙 방식
* 부가 기능을 제공하는 Proxy를 생성하여 실제 타깃(Target) 오브젝트의 변형없이 위빙을 수행 → 프록시 패턴
* 실제 런타임 상, Method 호출 시에 위빙이 이루어 짐
* 소스파일, 클래스 파일에 대한 변형이 없다는 장점
* 포인트 컷에 대한 어드바이스 적용 갯수가 늘어 날수록 성능이 떨어지고, 메소드 호출에 대해서만 어드바이스를 적용 할 수 있다.



## filter vs interceptor?



## JDBC?

### Connection Pool?



## 스프링 프로젝트에서 메모리 누수가 일어나는 경우는 어떤 경우인가?

wrapper 클래스의 사용으로 오토박싱된 메모리가 해제 되지 않는 현상

캐쉬로 객체를 사용하고 해제 하지 않는 경우

자료구조를 생성하면서 제대로 처리하지 않는 경우



## 왜 (단위)테스트를 작성해야 하는가?

테스트는 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 작성한 코드를 확신할 수 있게 해준다. 코드나 적용한 기술이 변경되더라도 변경하기 이전과 동일한 기능을 잘 수행한다는 것을 보장해준다. 또한 새로운 기능을 추가함으로써 기존 기능들이 영향을 받지 않고 잘 동작하는지도 확인할 수 있다.

테스트의 결과가 원하는 대로 나오지 않으면 코드나 설계에 결함이 있다는 것을 바로 알 수 있으므로 빠르게 오류를 제거할 수 있다. 테스트를 통과한 기능은 정상적으로 동작한다는 것이 보장되기 때문에 구현된 코드에 대한 확신을 가지고 다른 기능을 개발할 수 있어 전체적인 개발 속도가 빨라질 수 있다.

기능마다 테스트 케이스를 꼼꼼하게 작성하면 발생 가능한 예외 상황이나 다른 클래스에 끼치는 영향 등을 다시 고려하지 않고 코드를 수정할 수 있어 유지보수성을 높일 수 있다.

단위 테스트로 테스트를 진행하지 않으면 하나의 기능을 테스트할 때 그와 관련된 모든 계층의 기능이 다 만들어져 있어야 한다. 또한, 테스트에 실패하면 테스트에 참여하는 클래스가 많아 원인을 찾기가 힘들다. 이런 경우 테스트를 준비하기도 힘들고 환경이 조금이라도 달라지면 결과가 동일하지 않을 수 있다.

단위 테스트를 충분히 거쳤다면 여러 클래스나 외부 시스템과의 통합 테스트를 진행할 때 오류가 발생할 확률도 줄어들고 발생하더라도 쉽게 처리할 수 있다.

단위 테스트로 개발자가 만든 코드가 원래 의도한 대로 동작하는지를 스스로 빨리 확인할 수 있다.



## 단위테스트를 작성할 때 주의해야 할 점은 무엇인가?

테스트 대상의 단위가 너무 크지 않아야 한다. 작을수록 테스트 코드를 이해하기 쉽고 작성하기도 쉽다. 논리적인 오류가 발생하여 결과가 바르게 나오지 않으면 원인을 찾기가 어려워진다. 작은 단위로 테스트를 진행하면 나중에 코드가 많아져도 작은 단위 테스트로 검증한 부분은 제외하고 접근할 수 있다.

코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. 외부 환경에 영향을 받지 않아야 하며, 테스트 실행 순서를 바꿔도 동일한 결과가 보장되어야 한다. 따라서, 테스트가 적절히 격리되어야 한다.

성공하는 테스트 뿐 아니라 네거티브 테스트도 만들어야 한다. 

기능 별로 최대한 자세한 시나리오에 따른 테스트를 작성해야 한다. 어떤 입력 값이 필요한지, 기대에 벗어나는 행동을 할 때 어떤 예외를 던지는지 등 다양한 시나리오에 대한 테스트를 작성한다면 테스트 자체만으로도 해당 기능의 명세서 역할을 할 수 있다. 이를 바탕으로 다른 사람들이 코드를 보고 이해하는데 도움을 줄 수 있고, 코드의 활용성을 높일 수 있다.

테스트 대상과 연결된 의존관계를 모두 차단하고 필요에 다라 이를 목 오브젝트로 대체하여 고립된 환경을 만든다. 이렇게 작성하면 테스트 작성도 간단하고 실행 속도도 빠르며, 외부 환경이 테스트 결과에 영향을 미치지 않는다.



## @Transactional 의 propagation 속성에 대해서 설명해 보시오.

https://deveric.tistory.com/86

트랜잭션의 동작방식을 제어할 수 있는 여러 속성들이 있는데 그 중에 하나가 `propagation` 이다. `Transaction propagation` 이란 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 있을 때 어떻게 동작할 것인가를 결정하는 방식이다.

* 트랜잭션 경계: 트랜잭션 시작 ~ `commit()` / `rollback()` 까지의 구간

<옵션 종류>

1. `PROPAGATION_REQUIRED`

   : 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여한다. 기본 트랜잭션 전파 속성. 진행 중인 트랜잭션에 참여하는 경우, 트랜잭션 경계의 끝에서 트랜잭션을 커밋시키지 않고, 최초 트랜잭션이 정상적으로 진행되야 커밋될 수 있다.

2. `PROPAGATION_REQUIRES_NEW`

   : 항상 새로운 트랜잭션을 시작한다. 진행 중인 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작한다. 독립적인 트랜잭션이 보장돼야 하는 코드에 적용한다.

3. `PROPAGATION_NOT_SUPPORTED`

   : 트랜잭션 없이 동작한다. 진행 중인 트랜잭션이 있어도 이를 무시한다. 트랜잭션에 참여하는 메소드가 많은 상황에서 특정 메소드만 트랜잭션 적용에서 제외할 때 유용하다.