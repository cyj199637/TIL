# 09. Etc

## 빌드와 배포?

### 빌드

* 컴파일: 작성한 소스 코드를 바이너리 코드로 변환하는 과정

* 링크: 여러 개로 분리한 소스 코드들을 컴파일한 결과물들에서 최종 실행 가능한 파일을 만들기 위해 필요한 부분을 

  ​		 찾아서 연결해 주는 작업

* 빌드: 소프트웨어를 실행 가능한 소프트웨어 산출물(ex. jar, war 등)로 만드는 과정

#### 빌드 도구

* 소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 **자동 생성**하는 프로그램
* 계속해서 늘어나는 라이브러리의 **자동 추가 및 관리**
* 라이브러리 버전을 **자동으로 동기화**
* ex) Ant, Maven, Gradle

### 배포

: 작성한 코드를 빌드하고, 빌드가 완성한 실행 가능한 파일을 사용자가 접근할 수 있는 환경에 배치하면 배포가 완료된 것

* git에 올려두고, 코드가 제대로 동작하는지 테스트 코드를 작성하고, 이를 수행 및 검증하는 작업까지

#### CI(Continuous Integration - 지속적 통합)

: 개발자를 위한 자동화 프로세스인 지속적 통합으로 모든 개발이 끝난 이후에 코드 품질을 관리하는 고전적 방식의 단점을 해소하기 위해 나타난 개념

1. 코드 통합
2. 통합한 코드가 제대로 동작하는지 테스트
3. 제대로 빌드가 되는지 테스트
4. 결과를 정리하고 버그가 존재한다면 기록

#### CD(Continuous Deploy - 지속적 배포)

: 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 관리하자는 개념

### 무중단 배포

기존에 동작하고 있는 (배포가 완료된) 서버가 있는 상태에서 새롭게 업데이트한 코드를 배포한다면 충돌이 발생한다. 따라서, 기존에 서비스 중인 서버를 잠시 내리고 코드를 배포한 후 다시 서버를 동작시켜야 한다. **하지만 서버가 다시 뜨는데 걸리는 시간만큼 다운 타임(유저에게 서비스 불가능한 시간)이 발생**한다.

#### 필요 조건

* 두 대 이상의 서버를 서비스해야 한다.
* 다운 타임이 발생하지 않도록 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야 한다.
* 비용을 줄이려면 배포할 때만 새롭게 서버를 띄우고 배포가 완료된 후에 기존 서버는 내린다.

#### 종류

* Rolling 배포: 하나의 서버를 로드밸런서에서 빼고 신규 서비스를 배포 후, 다시 로드밸런서에 넣는 과정을 모든 서버마다 반복
  * 배포할 서버가 여러 개라면 배포가 모두 끝나기 전까지는 누구는 기존 서비스를 제공받고 누구는 업데이트된 서비스를 제공받는다는 문제가 발생
  * 1대에 배포하는 것보다 최소 2배 이상 느림
* Canary 배포: 소수의 유저만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때, 다른 모든 서버에 배포
* Blue/Green 배포: 실제로 서비스 중인 환경(Blue)과 새롭게 배포할 환경(Green)을 세트로 준비해서 배포
  * 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠름
  * 언제나 Green 환경이 떠있기 때문에 만약 잘못된 버전으로 배포한다면 빠르게 롤백 가능
  * 언제나 Green 환경이 떠있기 때문에 비용이 2배 이상



## Redis를 왜 사용하는가?

### Redis

: 딕셔너리 구조(Key - Value)를 가진 인메모리 데이터베이스

데이터베이스보다 더 빠른 메모리(Main Memory-DRAM)에 더 자주 접근하고 덜 자주 바뀌는 데이터를 저장하자라는 취지에서 나온 것이 인메모리 데이터베이스

<Redis 자료구조>

* String: Key - Value 쌍 / Java의 Map Entry
* List: Key - List 쌍 / Java의 LinkedList
* Set: Key - Set 쌍 / Java의 HashSet
* Sorted Set: Key - Set 쌍 / Java의 TreeSet / Score라는 숫자 값으로 순서가 정해짐
* Hash: Key - Hash 쌍 / Java의 HashMap(or Object)

### 자바와 같은 자료구조를 가지는데 왜 Redis를 따로 사용하는가?

: 자바 객체로 데이터를 저장하면 서버가 여러 대인 경우 서버마다 다른 데이터를 가지고 있을 수 있기 때문에 일관성 문제가 발생할 수 있다. 또한 멀티 스레드 환경에서 Race Condition 문제가 발생할 수 있다.

* Race Condition: 여러 개의 스레드가 경합하는 것 → 컨텍스트 스위칭으로 인해 원하지 않는 결과를 얻을 수 있음

Redis는 Race Condition 문제를 해결하기 위해 기본적으로 싱글 스레드이며, Redis 자료구조는 Atomic Critical Section에 대한 동기화를 제공한다. 또한 서로 다른 트랜잭션의 읽기/쓰기 작업을 동기화한다.

* Critical Section: 동시에 여러 프로세스가 접근하면 안되는 영역

따라서, 여러 서버에서 같은 데이터를 공유할 때 주로 사용하고, 단일 서버라면 Redis의 Atomic 자료구조나 캐시 기능을 이용한다.

### Redis는 왜 싱글 스레드인가?

* Event Driven(비동기)
* IO - bound Process: CPU 연산보다는 메모리 IO 관련 연산의 비중이 큼
* 컨텍스트 스위칭의 효율이 적음
* 개발하고 사용하는데 쉬움

### Redis 사용 시 주의해야 할 점

* 싱글 스레드이므로 시간 복잡도를 고려해서 명령어를 사용해야 함

  → 전체 데이터를 다루는 명령어는 사용하지 않는게 좋음 ex) keys, flush, getAll 등

* 인메모리 특성상 메모리 파편화, 가상 메모리, Replication - Fork 등의 이해가 필요



## Jenkins를 왜 사용하는가?

Travis CI와의 비교

* 통합: 개인이 작업한 코드를 공용 작업 환경에 올리고 병합하는 과정
  * 커밋(git) → 빌드(maven) → 테스트(junit5) → 통합
  * 그리고 위의 통합 과정을 전반적으로 관리하고 자동화 시켜주는 것이 Jenkins같은 CI 툴
* 배포: 통합 과정의 결과로 나온 산출물을 배포하는 것

애자일 개발 방법론은 빠른 배포를 기반으로 하는데 CI는 애자일에서 필요한 속도를 얻는데 도움을 준다. 통합 과정은 위와 같이 많은 단계를 거쳐야 한다.

* 애자일 개발 방법론: 빠르게 변화하는 고객의 요구사항에 대응하기 위해 짧은 주기로 프로젝트를 진행하는 것
  * 요구 사항 분석이나 설계에 시간을 쓰지 않고 추상적인 계획만 세우고 이를 바탕으로 빠르게 개발
  * 개발한 프로그램을 통합하고 테스트를 거쳐 배포
  * 배포 후 고객이 만족하지 못하면 변경 사항을 추가하여 같은 단계로 진행

고전적인 통합 방식의 경우, 개발자들이 각자 개발한 소스코드를 퀄리티 컨트롤(단위 테스트, 빌드 등)을 거치지 않고 커밋을 하고, 대부분의 기능 개발이 끝나게 되는 마지막에 통합을 하고 테스트를 진행한다. 따라서 버그 및 장애를 일으키는 이슈들이 쌓이게 되고, 통합을 하는 시점에 모두 해결해야 한다. 버그를 찾는데 굉장히 오랜 시간이 걸릴 수 있다.

이를 해결하기 위해서 **통합을 짧은 주기로 자주!** 즉, 지속적으로 하게 되면 이러한 **문제 요소들을 조기 식별**할 수 있으며, 공용 레포지토리에는 신뢰성 있는 소스코드들만 남길 수 있게 되므로 **소프트웨어의 품질과 생산성이 향상**할 수 있습니다.

지속적인 통합을 한다는 점에서 한 번에 많은 통합 과정을 진행하던 과거에 비해 훨씬 소스코드 **병합이 쉬워지고**, 병합 과정에서 **이슈를 빠르게 발견**할 수 있다는 점이 큰 장점입니다. 이를 통해 **소스코드의 높은 퀄리티를 유지**할 수 있습니다.

 또한 커밋만 하면 위의 통합 과정이 자동으로 실행되기 때문에 개발자들이 개발에만 신경 쓸 수 있는 환경을 구성할 수 있어서 **개발의 생산성을 높일 수 있다**는 장점이 있습니다.

그래서 Jenkins를 사용한다.



## Docker를 왜 사용하는가?

https://deveric.tistory.com/101

Docker를 사용하지 않은 환경에서는 자신의 컴퓨터에서 돌려 본 후, 상용 서버로 애플리케이션을 배포했을 때 고려해야 할 사항이 정말 많습니다. 각종 환경 변수, OS 호환성, 하드웨어 차이에 따른 이슈 등등 많은 것들을 관리해야 했습니다. 이 때문에 로컬에서 잘 돌아가던 애플리케이션이 서버만 가면 시작조차 되지 않을 수도 있다.

또 자신의 컴퓨터에 설정해 놓거나, 설치해 둔 프로그램은 사람마다 모두 다릅니다. 그렇기 때문에 제 컴퓨터에서 돌아가는 소스코드가 다른 사람의 컴퓨터에서도 멀쩡히 돌아간다는 보장을 받을 수 없었죠. 특정 컴퓨터의 환경을 맞춰야만 돌아가는 애플리케이션은 설치하기도, 배포하기도 까다롭고 어려웠죠.

그래서 환경에 관계없는 애플리케이션 구동을 위해 Docker를 개발하게 되었고 이는 Immutable Infrastructure라는 개념을 만들었습니다.

프로그램의 실행 환경과 어플리케이션을 같이 묶어서 Docker 엔진 위에만 올리면 OS, 환경과 상관없이 작동되도록 만드는 추상화 기법입니다. 그리고 이는 곧 어느 환경에서나 작동하는 애플리케이션이 됩니다. Immutable Infrastruecure는 다음과 같은 장점을 가지고 있습니다.

개발자의 컴퓨터에서 잘 돌아가는 환경이 있다면, 이를 모두 묶어버려서 하나의 파일로 만들어버리고 이를 서버에 올리면 잘 돌아가지 않을까? 라는 고민에서 생긴 것이 바로 Docker Image입니다.

Docker에서는 기본적으로 제공하는 Base Image가 있습니다. 여기에 애플리케이션에 필요한 라이브러리, 소스 등을 설치한 후 다시 이미지를 만들 수 있습니다. 일반적으로 이미지를 제작한다고 하면 이러한 베이스 이미지를 기초로 만든 이미지를 뜻합니다. Docker에서는 이 모든 환경을 하나의 이미지 파일로 묶어버립니다.

이렇게 모든 환경을 묶어버린 이미지는 실행 환경에 영향을 받지 않습니다. Docker 엔진 위에서 실행하기만 한다면 개발자가 설계한 환경 위에서 정해진 라이브러리와 소스를 실행합니다. 제작된 이미지는 파일이기 때문에 이를 실행하기 위해서는 파일을 프로세스로 만들어야 합니다. 이를 위해 Docker에서는 이미지를 사용하여 Container를 제작하여 운영체제에서 돌아가는 프로세스를 만듭니다.

#### 편리한 관리

서비스 운영 환경을 이미지로 생성하여 이 이미지만 관리하면 됩니다. 이미지는 버전관리 시스템을 활용할 수 있습니다.

#### 확장

이미지 하나로 서버를 손쉽게 확장할 수 있습니다. 클라우드의 Auto Scaling기능과 연동하면 수평 확장이 가능합니다.

#### 테스트

어느 PC나 환경에서든 이미지를 실행하면 서비스 운영 환경과 같은 환경이 구성됩니다. 서버에 올린 다음 테스트하지 않아도 서버 환경과 유사하게 테스타가 가능합니다.

#### 가벼움

Docker는 OS를 분리하여 이미지로 제작합니다. 그렇기 때문에 가볍고 어디서든 실행 가능한 환경을 제공합니다.



## Docker 네트워크?

https://deveric.tistory.com/112



## 마이크로 서비스 아키텍쳐를 왜 사용하는가?

https://d2.naver.com/helloworld/6080222

모놀리식 아키텍처 단점

1. 코드의 내용이 방대에서 버그를 고치고 새 기능을 정확하게 구현하기가 힘들고 시간이 오래 걸린다.

2. 개발이 느려진다.

   : 애플리케이션이 너무 커져서 로컬 PC에서 실행 속도도 느려지고, 빌드 시간도 오래 걸린다.

3. 커밋부터 배포까지의 과정이 길어진다.

   : 여러 개발자가 같은 코드베이스에 소스 커밋을 하기 때문에 소스 병합 시 힘들어진다. 하나의 모듈만 개발되어도 전체 애플리케이션을 배포해야 한다. 또한 코드베이스가 너무 복잡해서 변경 영향도가 제대로 파악되지 않으므로 개발자는 CI 서버에서 전체 테스트 스위트를 한 번씩 돌려야 하며, 이로 인해 테스트 시간이 오래 걸린다.

4. 확장하기 어렵다.

   : 모듈마다 리소스 요건이 서로 다를 수 있기 때문이다.

5. 신뢰성이 부족하다.

   : 철저하게 테스트하기 어렵고, 테스트가 부족하면 결국 프로덕션에 버그가 발생할 가능성도 높아진다. 또한, 모듈 간 결함 격리가 되지 않아 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션이 중단될 수 있다.

6. 새로운 기술을 도입하기 어렵다.

   : 최신 기술을 도입하기 위해 전체 애플리케이션을 다시 개발하기에는 비용과 리스크가 크다. 따라서, 오래된 기술을 계속해서 사용할 수 밖에 없다.

마이크로서비스 아키텍쳐 장점

1. 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.

   : 자동화 테스트를 작성하기 쉽고, 더 빨리 실행되며, 애플리케이션 버그도 줄어든다.

2. 서비스 규모가 작아 관리하기 쉽다.

3. 서비스를 독립적으로 배포/확장할 수 있다.

   : 추가 기능이나 확장이 필요하면 해당 모듈만 변경하면 된다. 서비스마다 상이한 리소스 요건에 맞추어 서버에 배포할 수 있다.

4. 마이크로서비스 아키텍쳐 덕분에 팀이 자율적으로 움직인다.

5. 결함 격리가 잘된다.

   : 한 서비스에 메모리 누수가 발생해도 해당 서비스만 영향을 받고 다른 서비스는 계속 정상 가동된다.

6. 새로운 기술을 실험하고 도입하기 쉽다.

### 그럼 MSA를 사용하면 무조건 좋기만 한가?

마이크로서비스 아키텍쳐 단점

1. 분산 시스템은 복잡해서 개발, 테스트, 배포가 어렵다.

   : 단일 애플리케이션 내부의 메서드 콜을 통한 정보 교환이 네트워크를 타고 모듈 간의 정보 교환으로 바뀌었기 때문이다. 단순 메소드 호출보다 복잡하며, 사용 불능 또는 지연 시간이 긴 원격 서비스, 부분 실패한 서비스 등을 잘 처리할 수 있도록 설계해야 한다. 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.

   특히, 서비스마다 DB가 따로 있기 때문에 트랜잭션 관리가 어렵다. 그래서 트랜잭션을 보장하는 분산 트랜잭션같은 기술을 도입해야 한다.

2. 여러 서비스에 걸친 기능을 배포할 때 잘 조정해야 한다.

   : 서비스 간 의존성에 따라 서비스 배포 계획을 빈틈없이 세워야 한다.

모놀리식 아키텍처 장점

1. 개발이 간단하다.
2. 애플리케이션을 쉽게 변경할 수 있다.
3. 테스트/배포/확장하기 쉽다.

### 어떨 때 MSA를 도입해야 하는가?