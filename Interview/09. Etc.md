# 09. Etc

## 빌드와 배포?

### 빌드

* 컴파일: 작성한 소스 코드를 바이너리 코드로 변환하는 과정

* 링크: 여러 개로 분리한 소스 코드들을 컴파일한 결과물들에서 최종 실행 가능한 파일을 만들기 위해 필요한 부분을 

  ​		 찾아서 연결해 주는 작업

* 빌드: 소프트웨어를 실행 가능한 소프트웨어 산출물(ex. jar, war 등)로 만드는 과정

#### 빌드 도구

* 소스 코드를 컴파일, 테스트, 정적 분석 등을 실시하여 실행 가능한 애플리케이션으로 **자동 생성**하는 프로그램
* 계속해서 늘어나는 라이브러리의 **자동 추가 및 관리**
* 라이브러리 버전을 **자동으로 동기화**
* ex) Ant, Maven, Gradle

### 배포

: 작성한 코드를 빌드하고, 빌드가 완성한 실행 가능한 파일을 사용자가 접근할 수 있는 환경에 배치하면 배포가 완료된 것

* git에 올려두고, 코드가 제대로 동작하는지 테스트 코드를 작성하고, 이를 수행 및 검증하는 작업까지

#### CI(Continuous Integration - 지속적 통합)

: 개발자를 위한 자동화 프로세스인 지속적 통합으로 모든 개발이 끝난 이후에 코드 품질을 관리하는 고전적 방식의 단점을 해소하기 위해 나타난 개념

1. 코드 통합
2. 통합한 코드가 제대로 동작하는지 테스트
3. 제대로 빌드가 되는지 테스트
4. 결과를 정리하고 버그가 존재한다면 기록

#### CD(Continuous Deploy - 지속적 배포)

: 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 관리하자는 개념

### 무중단 배포

기존에 동작하고 있는 (배포가 완료된) 서버가 있는 상태에서 새롭게 업데이트한 코드를 배포한다면 충돌이 발생한다. 따라서, 기존에 서비스 중인 서버를 잠시 내리고 코드를 배포한 후 다시 서버를 동작시켜야 한다. **하지만 서버가 다시 뜨는데 걸리는 시간만큼 다운 타임(유저에게 서비스 불가능한 시간)이 발생**한다.

#### 필요 조건

* 두 대 이상의 서버를 서비스해야 한다.
* 다운 타임이 발생하지 않도록 실제 서비스 중인 서버와 새롭게 배포한 서버가 동시에 존재해야 한다.
* 비용을 줄이려면 배포할 때만 새롭게 서버를 띄우고 배포가 완료된 후에 기존 서버는 내린다.

#### 종류

* Rolling 배포: 하나의 서버를 로드밸런서에서 빼고 신규 서비스를 배포 후, 다시 로드밸런서에 넣는 과정을 모든 서버마다 반복
  * 배포할 서버가 여러 개라면 배포가 모두 끝나기 전까지는 누구는 기존 서비스를 제공받고 누구는 업데이트된 서비스를 제공받는다는 문제가 발생
  * 1대에 배포하는 것보다 최소 2배 이상 느림
* Canary 배포: 소수의 유저만 사용하는 환경(Canary 환경)에 신규 버전을 배포하고 문제가 없다고 판단됐을 때, 다른 모든 서버에 배포
* Blue/Green 배포: 실제로 서비스 중인 환경(Blue)과 새롭게 배포할 환경(Green)을 세트로 준비해서 배포
  * 새롭게 배포할 환경에만 배포하면 되기 때문에 배포 속도가 매우 빠름
  * 언제나 Green 환경이 떠있기 때문에 만약 잘못된 버전으로 배포한다면 빠르게 롤백 가능
  * 언제나 Green 환경이 떠있기 때문에 비용이 2배 이상



## Jenkins를 왜 사용하는가?

Travis CI와의 비교



## Docker를 왜 사용하는가?

https://deveric.tistory.com/101



## Docker 네트워크?

https://deveric.tistory.com/112



## 마이크로 서비스 아키텍쳐를 왜 사용하는가?

https://d2.naver.com/helloworld/6080222

모놀리식 아키텍처 단점

1. 코드의 내용이 방대에서 버그를 고치고 새 기능을 정확하게 구현하기가 힘들고 시간이 오래 걸린다.

2. 개발이 느려진다.

   : 애플리케이션이 너무 커져서 로컬 PC에서 실행 속도도 느려지고, 빌드 시간도 오래 걸린다.

3. 커밋부터 배포까지의 과정이 길어진다.

   : 여러 개발자가 같은 코드베이스에 소스 커밋을 하기 때문에 소스 병합 시 힘들어진다. 하나의 모듈만 개발되어도 전체 애플리케이션을 배포해야 한다. 또한 코드베이스가 너무 복잡해서 변경 영향도가 제대로 파악되지 않으므로 개발자는 CI 서버에서 전체 테스트 스위트를 한 번씩 돌려야 하며, 이로 인해 테스트 시간이 오래 걸린다.

4. 확장하기 어렵다.

   : 모듈마다 리소스 요건이 서로 다를 수 있기 때문이다.

5. 신뢰성이 부족하다.

   : 철저하게 테스트하기 어렵고, 테스트가 부족하면 결국 프로덕션에 버그가 발생할 가능성도 높아진다. 또한, 모듈 간 결함 격리가 되지 않아 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션이 중단될 수 있다.

6. 새로운 기술을 도입하기 어렵다.

   : 최신 기술을 도입하기 위해 전체 애플리케이션을 다시 개발하기에는 비용과 리스크가 크다. 따라서, 오래된 기술을 계속해서 사용할 수 밖에 없다.

마이크로서비스 아키텍쳐 장점

1. 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.

   : 자동화 테스트를 작성하기 쉽고, 더 빨리 실행되며, 애플리케이션 버그도 줄어든다.

2. 서비스 규모가 작아 관리하기 쉽다.

3. 서비스를 독립적으로 배포/확장할 수 있다.

   : 추가 기능이나 확장이 필요하면 해당 모듈만 변경하면 된다. 서비스마다 상이한 리소스 요건에 맞추어 서버에 배포할 수 있다.

4. 마이크로서비스 아키텍쳐 덕분에 팀이 자율적으로 움직인다.

5. 결함 격리가 잘된다.

   : 한 서비스에 메모리 누수가 발생해도 해당 서비스만 영향을 받고 다른 서비스는 계속 정상 가동된다.

6. 새로운 기술을 실험하고 도입하기 쉽다.

### 그럼 MSA를 사용하면 무조건 좋기만 한가?

마이크로서비스 아키텍쳐 단점

1. 분산 시스템은 복잡해서 개발, 테스트, 배포가 어렵다.

   : 단일 애플리케이션 내부의 메서드 콜을 통한 정보 교환이 네트워크를 타고 모듈 간의 정보 교환으로 바뀌었기 때문이다. 단순 메소드 호출보다 복잡하며, 사용 불능 또는 지연 시간이 긴 원격 서비스, 부분 실패한 서비스 등을 잘 처리할 수 있도록 설계해야 한다. 타임아웃이 발생할 정도의 지연이 발생하면 순식간에 다른 모듈로 전파되어 전체 시스템이 마비되는 등의 악영향을 끼칠 수 있다.

   특히, 서비스마다 DB가 따로 있기 때문에 트랜잭션 관리가 어렵다. 그래서 트랜잭션을 보장하는 분산 트랜잭션같은 기술을 도입해야 한다.

2. 여러 서비스에 걸친 기능을 배포할 때 잘 조정해야 한다.

   : 서비스 간 의존성에 따라 서비스 배포 계획을 빈틈없이 세워야 한다.

모놀리식 아키텍처 장점

1. 개발이 간단하다.
2. 애플리케이션을 쉽게 변경할 수 있다.
3. 테스트/배포/확장하기 쉽다.

### 어떨 때 MSA를 도입해야 하는가?