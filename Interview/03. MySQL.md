# 03. MySQL

(볼드체로 표시한 부분도 답변 준비할 것)

## 인덱스가 무엇인가?

### 인덱스를 사용했을 때 어떤 점이 좋은가?



## 외래키를 쓸 때 어떤 점에서 좋고 어떤 점에서 안 좋은가?

외래키는 데이터의 (참조) 무결성을 보장해준다. 예를 들어, A 테이블의 code 컬럼은 B 테이블에 있는 값만 사용해야 하는 상황이라고 가정하자. 그런데 다양한 이유로 B 테이블에는 없는 값이 A 테이블의 code 컬럼에 있을 수 있다. 이렇게 참조 무결성이 깨지는 문제를 외래키를 생성하여 DBMS 차원에서 막아준다.

그러나 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하여 잠금이 여러 테이블로 전파되고 그로 인해 **데드락**이 발생할 때가 많다. 또한 상당한 디스크 IO를 유발한다.



## 트랜잭션의 격리 수준에 대해서 설명해 보시오.

트랜잭션의 격리 수준이란 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다. 격리 수준이 높을수록 트랜잭션 간의 데이터 격리 정도가 높아지며, **동시성은 떨어지는 것이 일반적**이다.

1. `READ UNCOMMITED`

   : 각 트랜잭션에서의 변경 내용이 커밋이나 롤백 여부와 상관없이 다른 트랜잭션에서 보여진다. `Dirty Read` 현상이 발생한다.

   * `Dirty Read` : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랙잭션에서 볼 수 있는 현상

     ex) A가 테이블에 데이터를 INSERT하는 상황이다. 아직 커밋되지 않은 상황이지만 다른 사용자 B가 같은 테이블을 읽는다면 해당 데이터를 조회할 수 있다. 만약 INSERT 도중 문제가 생겨 롤백해버린다 해도 B는 여전히 해당 데이터를 정상적인 데이터로 처리하기 때문에 문제가 발생할 수 있다.

2. `READ COMMITED`

   : 어떤 트랜잭션에서 데이터를 변경해도 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다. 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. `Dirty Read` 현상은 발생하지 않지만 `Non-Repeatable Read` 현상이 발생한다.

   * `Dirty Read` X : ex) A가 테이블에 데이터를 INSERT하는 상황이다. INSERT한 데이터는 바로 테이블에 반영되고 이전 데이터는 **언두 영역**으로 백업된다. 아직 커밋되지 않은 상황이지만 다른 사용자 B가 같은 테이블을 읽는다면 언두 영역에 백업된 데이터를 조회한다.

   * `Non-Repeatable Read` : 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행해도 다른 결과를 가져오는 현상

     ex) B가 테이블을 조회할 때는 name이 C인 데이터가 없었다. B의 트랜잭션이 끝나지 않은 상황에서 A가 테이블에 어떤 데이터의 name을 C로 변경하고 커밋한다. 이후 B가 같은 쿼리로 조회하면 name이 C인 데이터가 조회된다.

3. `REPEATABLE READ`

   : MySQL의 **InnoDB 스토리지 엔진**에서 기본적으로 사용되는 격리 수준이다. `Dirty Read` 현상과`Non-Repeatable Read` 현상은 발생하지 않지만 `Phantom Read` 현상이 발생한다.

   * `Non-Repeatable Read` X : **MVCC**를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다. 이를 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호의 구간 내에서 백업된 언두 영역 데이터를 삭제되지 않는다.

     ex) 트랜잭션 번호가 10인 B가 테이블을 조회할 때는 name이 C인 데이터가 없다. B의 트랜잭션이 끝나지 않은 상황에서 A(트랜잭션 번호 12)가 테이블에 어떤 데이터의 name을 C로 변경하고 커밋한다. 그러나 B는 트랜잭션 번호를 받은 이후부터 번호가 10보다 작은 트랜잭션 번호에서 변경된 데이터만 본다.

   * `Phantom Read` : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상

     `SELECT ... FOR UPDATE` 나 `SELECT ... LOCK IN SHARE MODE` 등은 SELECT 하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없어 현재 레코드의 값을 가져오게 된다.

4. `SELIALIZABLE`

   : 모든 데이터 부정합 문제가 발생하지 않는 격리 수준이다. 그러나 읽기 작업도 **읽기 잠금**을 획득해야만 하며, 동시에 다른 트랜잭션은 해당 레코드를 변경하지 못한다. 즉, 한 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 사용할 수 없다. (MySQL의 InnoDB 스토리지 엔진에서는 3단계에서도 `Phantom Read` 가 발생하지 않기 때문에 이 단계를 사용하지 않아도 된다.)

### 왜 격리 수준이 높아질 수록 동시성이 떨어지는가?



## MySQL 성능이 나빠지면 어떻게 해야하는가?

: 여러 가지 중 하나는 슬로우 쿼리 로그를 본다. 모니터링을 통해 느린 쿼리가 나타나면 알림이 오도록 하게 한다.