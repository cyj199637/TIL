# 01. Java

## Java vs Python?



## Java 7 / 8에서는 무엇이 달라졌는가?

https://jeong-pro.tistory.com/209?category=793347

- `Spring5 Webflux` <- 이게 네티를 사용함



## Primitive type vs Reference type?



## 인터페이스 vs 추상클래스?

https://jeong-pro.tistory.com/82?category=793347



## static inner 클래스 / inner 클래스 언제 쓰이는가?

- inner 클래스 중에서도 private/public 은 언제 쓰이나



## 접근제한자?



## final과 불변 객체?

### final

: 한 번만 할당 가능하다는 선언

<사용하는 이유>

* 값에 대한 검증을 할 필요가 없으므로 로직 구현에만 집중할 수 있음
* 버그 발생 가능성이 줄어듦
* 버그를 빨리 찾게 됨
* 코드 품질이 높아져 변화에 좀 더 빠르게 대응할 수 있음
* 서비스 안정성이 높아짐



### 불변 객체

: 한 번 생성되면 상태를 수정할 수 없는 객체 → 생성이 된 불변 객체는 신뢰할 수 있음

<사용하는 이유>

* 멀티스레드 환경에서 스레드 동기화 문제 방지



## equals()와 hashcode()에 대해서 설명해보시오.

### 왜 equals()를 재정의할 때 hashcode()도 같이 재정의하는가?

### 왜 hashcode()를 제대로 정의하지 않으면 성능이 나빠지는가?





## String vs StringBuilder vs StringBuffer?

https://jeong-pro.tistory.com/85?category=793347



## Generic?

https://jeong-pro.tistory.com/100?category=793347



## 자바 직렬화?

**직렬화**란 객체를 다른 환경(파일, 메모리, DB 등)에 저장했다가 나중에 재구성할 수 있게 만드는 일련의 과정이다.

<사용 시점>

* 객체의 상태를 영속(저장)해야할 필요가 있을 때
* 다른 VM에게 혹은 바이트 스트림으로 변환해서 객체의 정보를 전달해야 할 때

그러나 자바 직렬화는 보안, 유지보수성, 테스트 등 많은 문제를 안고 있어 잘 쓰이지 않는다. 따라서, 자바 직렬화 보다는 다른 직렬화 메커니즘을 사용하거나 JSON, CSV 등 크로스 플랫폼에 적합한 데이터 표현을 사용하는 것이 좋다.

ex1) 보안 - 보이지 않는 생성자, `readObject()`

클래스 A는 value 속성에 양수만 가질 수 있다고 가정하자. 처음 객체를 생성할 때 value 값을 검증하고, 이를 직렬화할 것이다. 그러나 악의를 가진 사람이 정상 생성된 직렬화 바이트 내부의 값을 수정해서 value 값을 음수로 바꿀 수 있다. 이때 만약 `ObjectInputStream` 의 `readObject()` 에 별다른 검증 로직이 없다면 역직렬화하는 과정에서 음수를 가진 A가 생성될 수 있다.

* 해결 방법1

  : 커스텀 직렬화 사용 → 직렬화 대상 클래스의 `readObject()` 에 검증 로직을 추가하여 재정의

* 해결 방법2

  : 직렬화 프록시 패턴 사용 → 1번 방법은 같은 검증 로직을 중복해서 작성하므로 개발자가 실수할 여지가 있다.

  * `writeReplace()` : 직렬화 과정에 간섭하여 특정 객체를 직렬화 결과로 반환

~~~ java
public class PositiveNumber implements Serializable {
    private final int value;
    
    public PositiveNumber(final int value) {
        this.value = value;
        // 4. 검증 로직을 중복해서 작성하지 않아도 역직렬화할 때 자동으로 검증
        checkPositive();
    }
    
    private void checkPositive() {
        if (this.value < 0) {
            throw new RuntimeException();
        }
    }
    // 2. writeReplace()로 직렬화 과정에서 중첩 클래스 객체를 직렬화
    private object writeReplace() {
        return new PositiveNumberProxy(this.value);
    }
    // 1. 원본 클래스 안에 프록시 객체를 생성하는 중첩 클래스를 작성
    private static class PositiveNumberProxy implements Serializable {
        private final int value;
        
        public PositiveNumberProxy(final int value) {
        	this.value = value;
    	}
        // 3. 역직렬화는 중첩 클래스에서 일어나지만 사용하고자 하는 객체는 원본 클래스이므로 readResolve()를 정의하여 원본 클래스의 객체를 생성
        private Object readResolve() {
            return new PositiveNumber(this.value);
        }
    }
}
~~~



ex2) 싱글톤 문제

기본적으로 `readObject()` 를 사용하게 되면 직렬화할 때의 객체와 역직렬화를 거친 객체는 서로 다른 객체로 생성이 된다. 즉, 싱글톤 객체를 직렬화했다가 역직렬화하여 사용한다면 서로 다른 두 객체가 생성되기 때문에 싱글톤 객체는 싱글톤의 성격을 잃어버리게 된다는 것이다.

* 해결 방법1

  : `readResolve()` 정의

  * `readResolve()` : 역직렬화 과정에 간섭하여 원하는 객체를 역직렬화 결과로 반환

~~~ java
public class MySingleton implements Serializable {
    private static final MySingleton INSTANCE = new MySingleton();
    // 클래스의 인스턴스 변수가 존재하는 경우, 해당 변수가 직렬화-역직렬화 대상이 되지 않도록 transient 예약어를 사용.(사용하지 않으면 참조 필드의 영역값을 훔쳐오는 행위가 가능해지기 때문)
    private final transient Object serializableObject;
    
    private MySingleton() {
    }
    
    public static MySingleton getInstance() {
        return INSTANCE;
    }
    
    // readObject()를 통해 역직렬화된 객체는 사용하지 않고 readResolve()에서 반환하는 객체를 사용
    private Object readResolve() {
        return INSTANCE;
    }
}
~~~

* 해결 방법2

  : Enum 클래스 이용 → 1번 방법은 불편한 점이 많기 때문에 위와 같은 경우에는 원소를 하나 가지는 Enum 클래스를 이용해서 싱글톤을 이용하면 직렬화-역직렬화 문제가 해결됨



## 자바 애플리케이션이 실행될 때 JVM에서 어떤 일이 일어나는지 설명해보시오.

https://jeong-pro.tistory.com/148?category=793347



## GC?

https://deveric.tistory.com/64

JVM의 Heap 영역에서 사용하지 않는 객체를 삭제하는 프로세스

<GC 수거 대상>

GC Roots부터 참조하고 있는 객체를 차례로 탐색하여 수거 대상을 찾아낸다. 특정 시점에 유효한 참조를 가지고 있는 객체를 Reachable, 그렇지 않은 객체를 Unreachable하다고 한다. GC Roots가 될 수 있는 데이터로는 Stack 영역의 데이터, method 영역의 static 데이터, JNI에 의해 생성된 객체 등이 있다. 즉, 이러한 데이터들이 참조하고 있지 않으면 해당 객체는 수거 대상이 된다.

<GC 동작 순서>

### Mark and Sweep or Compact

1. Mark: GC Roots부터 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 살펴보고 Unreachable 객체에 마
2. -1. Sweep: Unreachable 객체들을 Heap에서 제거
   * 단일 스레드가 Old 영역 전체를 훑음

2. -2. Summary
   * 멀티 스레드가 Old 영역을 분리해서 훑음
3. Compact(알고리즘에 따라 다름): 메모리 단편화를 방지하기 위해 Sweep 후, 분산된 객체들을 Heap의 시작 주소로 모음

<GC가 일어나는 시점>

* Young 영역: 새로운 객체들이 할당되는 영역
  * Eden: 새로운 객체들이 할당됨 → 공간이 없으면 Minor GC 발생
  * Survivor[0] / [1]: Minor GC에서 살아남은 객체들이 이동 → 객체들의 age 값 증가 
    * Survivor의 두 공간 중 하나는 무조건 비어있어야 함
    * Minor GC가 일어날 때마다 사용하는 Survivor 공간이 바뀜
* Old 영역: Young 영역에서 오랫동안 살아남은 객체들이 존재하는 영역
  * 객체의 age가 age threshold에 도달하면 Old 영역으로 이동
  * 공간이 없으면 Major GC 발생
* Stop the World: GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
  * GC를 실행하는 스레드 외의 모든 스레드가 멈춤

<종류>

1. Serial GC
   * 싱글 스레드로 GC를 처리 → 다른 GC에 비해 Stop-the-World 시간이 긺
   * Mark-Sweep-Compact 알고리즘 사용
2. Parallel GC
   * Java 8의 default GC
   * Young 영역의 GC를 멀티스레드로 처리 → Serial GC에 비해 Stop-the-World 시간이 짧음
3. Parallel Old GC
   * Parallel GC를 개선
   * Old 영역의 GC도 멀티스레드로 처리
   * Mark-Summary-Compact 알고리즘 사용
4. CMS GC
   * Stop-the-World 시간을 줄이기 위해 고안됨 → Compact 과정이 없음
5. G1 GC
   * Java 9+의 default GC
   * CMS GC를 개선 → Compact 진행
   * Heap을 일정한 Region으로 나눔 → 전체 Heap이 아닌 Region 단위로 탐색