# 01. Java

## Java vs Python?



## Java 7 / 8에서는 무엇이 달라졌는가?

https://jeong-pro.tistory.com/209?category=793347

- `Spring5 Webflux` <- 이게 네티를 사용함



## Primitive type vs Reference type?



## 인터페이스 vs 추상클래스?

https://jeong-pro.tistory.com/82?category=793347



## static inner 클래스 / inner 클래스 언제 쓰이는가?

- inner 클래스 중에서도 private/public 은 언제 쓰이나



## 접근제한자?



## final과 불변 객체?

### final

: 한 번만 할당 가능하다는 선언

<사용하는 이유>

* 값에 대한 검증을 할 필요가 없으므로 로직 구현에만 집중할 수 있음
* 버그 발생 가능성이 줄어듦
* 버그를 빨리 찾게 됨
* 코드 품질이 높아져 변화에 좀 더 빠르게 대응할 수 있음
* 서비스 안정성이 높아짐



### 불변 객체

: 한 번 생성되면 상태를 수정할 수 없는 객체 → 생성이 된 불변 객체는 신뢰할 수 있음

<사용하는 이유>

* 멀티스레드 환경에서 스레드 동기화 문제 방지



## equals()와 hashcode()에 대해서 설명해보시오.

### 왜 equals()를 재정의할 때 hashcode()도 같이 재정의하는가?

### 왜 hashcode()를 제대로 정의하지 않으면 성능이 나빠지는가?





## String vs StringBuilder vs StringBuffer?

https://jeong-pro.tistory.com/85?category=793347



## Generic?

https://jeong-pro.tistory.com/100?category=793347



## 자바 직렬화?

**직렬화**란 객체를 다른 환경(파일, 메모리, DB 등)에 저장했다가 나중에 재구성할 수 있게 만드는 일련의 과정이다.

<사용 시점>

* 객체의 상태를 영속(저장)해야할 필요가 있을 때
* 다른 VM에게 혹은 바이트 스트림으로 변환해서 객체의 정보를 전달해야 할 때

그러나 자바 직렬화는 보안, 유지보수성, 테스트 등 많은 문제를 안고 있어 잘 쓰이지 않는다. 따라서, 자바 직렬화 보다는 다른 직렬화 메커니즘을 사용하거나 JSON, CSV 등 크로스 플랫폼에 적합한 데이터 표현을 사용하는 것이 좋다.

ex1) 보안 - 보이지 않는 생성자, `readObject()`

클래스 A는 value 속성에 양수만 가질 수 있다고 가정하자. 처음 객체를 생성할 때 value 값을 검증하고, 이를 직렬화할 것이다. 그러나 악의를 가진 사람이 정상 생성된 직렬화 바이트 내부의 값을 수정해서 value 값을 음수로 바꿀 수 있다. 이때 만약 `ObjectInputStream` 의 `readObject()` 에 별다른 검증 로직이 없다면 역직렬화하는 과정에서 음수를 가진 A가 생성될 수 있다.

* 해결 방법1

  : 커스텀 직렬화 사용 → 직렬화 대상 클래스의 `readObject()` 에 검증 로직을 추가하여 재정의

* 해결 방법2

  : 직렬화 프록시 패턴 사용 → 1번 방법은 같은 검증 로직을 중복해서 작성하므로 개발자가 실수할 여지가 있다.

  * `writeReplace()` : 직렬화 과정에 간섭하여 특정 객체를 직렬화 결과로 반환

~~~ java
public class PositiveNumber implements Serializable {
    private final int value;
    
    public PositiveNumber(final int value) {
        this.value = value;
        // 4. 검증 로직을 중복해서 작성하지 않아도 역직렬화할 때 자동으로 검증
        checkPositive();
    }
    
    private void checkPositive() {
        if (this.value < 0) {
            throw new RuntimeException();
        }
    }
    // 2. writeReplace()로 직렬화 과정에서 중첩 클래스 객체를 직렬화
    private object writeReplace() {
        return new PositiveNumberProxy(this.value);
    }
    // 1. 원본 클래스 안에 프록시 객체를 생성하는 중첩 클래스를 작성
    private static class PositiveNumberProxy implements Serializable {
        private final int value;
        
        public PositiveNumberProxy(final int value) {
        	this.value = value;
    	}
        // 3. 역직렬화는 중첩 클래스에서 일어나지만 사용하고자 하는 객체는 원본 클래스이므로 readResolve()를 정의하여 원본 클래스의 객체를 생성
        private Object readResolve() {
            return new PositiveNumber(this.value);
        }
    }
}
~~~



ex2) 싱글톤 문제

기본적으로 `readObject()` 를 사용하게 되면 직렬화할 때의 객체와 역직렬화를 거친 객체는 서로 다른 객체로 생성이 된다. 즉, 싱글톤 객체를 직렬화했다가 역직렬화하여 사용한다면 서로 다른 두 객체가 생성되기 때문에 싱글톤 객체는 싱글톤의 성격을 잃어버리게 된다는 것이다.

* 해결 방법1

  : `readResolve()` 정의

  * `readResolve()` : 역직렬화 과정에 간섭하여 원하는 객체를 역직렬화 결과로 반환

~~~ java
public class MySingleton implements Serializable {
    private static final MySingleton INSTANCE = new MySingleton();
    // 클래스의 인스턴스 변수가 존재하는 경우, 해당 변수가 직렬화-역직렬화 대상이 되지 않도록 transient 예약어를 사용.(사용하지 않으면 참조 필드의 영역값을 훔쳐오는 행위가 가능해지기 때문)
    private final transient Object serializableObject;
    
    private MySingleton() {
    }
    
    public static MySingleton getInstance() {
        return INSTANCE;
    }
    
    // readObject()를 통해 역직렬화된 객체는 사용하지 않고 readResolve()에서 반환하는 객체를 사용
    private Object readResolve() {
        return INSTANCE;
    }
}
~~~

* 해결 방법2

  : Enum 클래스 이용 → 1번 방법은 불편한 점이 많기 때문에 위와 같은 경우에는 원소를 하나 가지는 Enum 클래스를 이용해서 싱글톤을 이용하면 직렬화-역직렬화 문제가 해결됨



## 자바 애플리케이션이 실행될 때 JVM에서 어떤 일이 일어나는지 설명해보시오.

https://jeong-pro.tistory.com/148?category=793347



## GC?

https://deveric.tistory.com/64

JVM의 Heap 영역에서 사용하지 않는 객체를 삭제하는 프로세스

### GC의 실행 과정?