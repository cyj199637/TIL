# 3.2 InnoDB 스토리지 엔진 아키텍처

### InnoDB

* 레코드 기반의 잠금 제공 → 높은 동시성 처리 가능 / 안정적 / 뛰어난 성능

![InnoDB](../images/InnoDB.jpg)



## 3.2.1 InnoDB 스토리지 엔진의 특성

1. 프라이머리 키에 의한 클러스터링
   * 프라이머리 키 값의 순서대로 디스크에 저장됨
2. 잠금이 필요 없는 일관된 읽기
   * MVCC로 락을 걸지 않고 읽기 작업을 수행할 수 있기 때문에 다른 트랜잭션이 가지고 있는 락을 기다리지 않고도 읽기 작업이 가능
3. 외래 키 지원
4. 자동 데드락 감지
   * 감지된 데드락은 관련 트랜잭션 중 롤백이 가장 용이한 트랜잭션을 자동 강제 종료
5. 자동화된 장애 복구
6. 오라클의 아키텍처 적용





## 3.2.2 InnoDB 버퍼 풀

* 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
* 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
  * 변경된 데이터를 모아서 처리하므로 랜덤 디스크 작업 횟수 감소
* 더티 페이지 관리
  * **더티 페이지** : 아직 디스크에 기록되지 않은 변경된 데이터
* `innodb_buffer_pool_size`





## 3.2.3 언두 로그

: UPDATE, DELETE 등 쿼리로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳

* 트랜잭션의 롤백 대비용
* 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는 데 사용





## 3.2.4 인서트 버퍼

: 변경해야 할 인덱스 페이지를 디스크로부터 읽어와서 업데이트해야 하는 경우, 사용하는 임시 메모리 공간

→ 업데이트를 즉시 실행하지 않고, 인서트 버퍼에 저장하여 사용자에게 결과를 반환하는 형태로 성능 향상

* 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하기 때문에 사용
* 인서트 버퍼에 임시로 저장돼 있는 인덱스 레코드 조각은 인서트 버퍼 머지 스레드에 의해 병합
* `innodb_change_buffering`





## 3.2.5 리두 로그 및 로그 버퍼

### 리두 로그

: 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일

* 변경된 데이터의 내용을 데이터 파일로 기록하는 작업은 디스크에서 랜덤하게 이루어지고, 이로 인한 부하를 줄이기 위해 InnoDB 버퍼 풀과 같은 장치가 포함
* 그러나 이 장치만으로 ACID를 보장할 수 없어 리두 로그 사용
* 리두 로그로 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있어 성능 향상

#### ACID

: 트랜잭션의 무결성을 보장하기 위해 반드시 필요한 4가지 요소

* A(Atomic): 원자성
* C(Consistent): 일관성
* I(Isolated): 격리성
* D(Durable): 한번 저장된 데이터는 지속적으로 유지돼야 함



### 로그 버퍼

: 리두 로그 버퍼링에 사용되는 공간





## 3.2.6 MVCC

: 하나의 레코드에 대해 여러 개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조

* 잠금을 사용하지 않는 일관된 읽기 제공
  * 언두 로그를 이용해 구현
* 데이터가 변경되면 버퍼 풀에 있는 데이터는 변경 내역이 바로 반영되고, 언두 로그에는 변경 이전 데이터 저장
* 커밋하면 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들고, 롤백하면 언두 영역에 있는 백업된 데이터를 버퍼 풀로 다시 복구한 후 언두 영역의 내용 삭제
* 언두 영역의 백업 데이터는 이를 필요로 하는 트랜잭션이 없을 때 삭제됨
* 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 함