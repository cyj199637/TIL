# 부록A. 동시성2

## 클라이언트/서버 예제

서버

- 연결을 기다리다 들어오는 메세지를 처리한 후, 다음 클라이언트 요청을 기다린다.

```java
ServerSocket serverSocket = new ServerSocket(8009)

while (keepProcessing) {
	try {
		Socket socket = server.Socket.accept();
		process(socket);
	} catch (Exception e) {
		handle(e);
	}
}
```

<br/>

클라이언트

```java
private void connectSendReceive(int i) {
	try {
		Socket socket = new Socket("localhost", PORT);
		MessageUtils.sendMessage(socket, Integer.toString(i));
		MessageUtils.getMessage(socket);
		socket.close();
	} catch (Exception e) {
		e.printStackTrace();
	}
}
```

<br/>

성능 테스트

- 시스템 작업 처리량을 검증하는 예시 케이스
- 시스템이 일련의 클라이언트 요청을 10초 내에 처리해야 함

```java
@Test(timeout=10000)
public void shouldRunInUnder10Seconds() throws Exception {
	Thread[] threads = createThreads();
	startAllThreads(threads);
	waitForAllThreadsToFinish(threads);
}
```

<br/>

테스트가 실패한다면 단일스레드 환경에서 속도를 끌어올릴 방법은 거의 없다.

다중 스레드를 사용하면 성능이 높아질까?

그럴지도 모르지만 먼저 애플리케이션이 어디서 시간을 보내는지 알아야 한다.

대개 시스템은 둘 다 하느라 시간을 보내지만, 특정 연산을 살펴보면 대개 하나가 지배적이다.

- I/O - 소켓 사용, DB 연결, 가상 메모리 스와핑 기다리기 등

  → 동시성이 성능을 높여주기도 한다.

       (시스템 한 쪽이 I/O를 기다리는 동안 다른 쪽이 뭔가를 처리해 놀고 있는 CPU를 효과적으로 활용 가능)

- 프로세서 - 수치 계산, 정규 표현식 처리, 가비지 컬렉션 등

  → 새로운 하드웨어를 추가해 성능을 높이는 방식이 적합

       (CPU 사이클은 한계가 있기 때문에 스레드를 늘인다고 빨라지지 않기 때문)

<br/>

### 스레드 추가하기

```java
void process(final Socket socket) {
	if (socket == null)
		return;

	Runnable clientHandler = new Runnable() {
		public void run() {
			try {
				String message = MessageUtils.getMessage(socket);
				MessageUtils.sendMessage(socekt, "Processed: " + message);
				closeIgnoringException(socket);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	};

	// 스레드 추가
	Thread clientConnection = new Thread(clientHandler);
	clientConnection.start();
}
```

<br/>

### 서버 살펴보기

위의 코드는 성능 테스트는 완료하지만 코드에서 최대 스레드 수를 명시하지 않으므로 이론상 JVM이 허용하는 수까지 생성이 가능하다.

너무 많은 사용자가 한꺼번에 몰리는 시스템이라면 동작을 멈출지도 모른다.

<br/>

그리고 현재 서버 프로그램의 process 함수는 단일 책임 원칙을 위반하고 있다.

- 현재 지고 있는 책임
    1. 소켓 연결 관리
    2. 클라이언트 처리
    3. 스레드 정책
    4. 서버 종료 정책

<br/>

다중 스레드 프로그램을 깨끗하게 유지하려면 잘 통제된 몇 곳으로 스레드 관리를 모아야 한다.

스레드를 관리하는 코드는 스레드만 관리해야 한다.

비동시성 문제까지 뒤섞지 않더라도 동시성 문제는 그 자체만으로도 추적하기 어렵기 때문이다.

<br/>

스레드 관리 책임을 클래스로 분리한다면 스레드 관리 전략이 변할 때 전체 코드에 미치는 영향이 작아지며 다른 책임을 간섭하지 않는다.

더구나 스레드를 걱정하지 않고서 다른 책임을 테스트하기가 훨씬 더 쉬워진다.

<br/>

```java
// 스레드 관련 코드 분리
public void run() {
	while (keppProcessing) {
		try {
			ClientConnection clientConnection = connectionManager.awaitClient();
			ClientRequestProcessor requestProcessor = new ClientRequestProcessor(clientConnection);
			clientScheduler.schedule(requestProcessor);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	connectionManager.shutdown();
}

// 동시성 정책 관련 코드 분리
public interface ClientScheduler {
	void schedule(ClientRequestProcessor requestProcessor);
}

public class ThreadPerRequestScheduler implements ClientScheduler {
	
	...
	
	public void schedule(final ClientRequestProcessor requestProcessor) {
		Runnable runnable = new Runnable() {
			public void run() {
				requestProcessor.process();
			}
		};

		Thread thread = new Thread(runnable);
		thread.start();
	}
}
```

<br/>

### 결론

동시성은 그 자체가 복잡한 문제이므로 다중 스레드 프로그램에서는 단일 책임 원칙이 특히 중요하다.

<br/><br/>

## 가능한 실행 경로

```java
public class IdGenerator {
	int lastIdUsed;

	public int incrementValue() {
		return ++lastIdUsed;
	}
}
```

스레드 하나가 IdGenerator 인스턴스 하나를 사용한다면 가능한 실행 경로도, 가능한 결과도 단 하나다.

그러나 스레드가 여러 개고 incrementValue 메소드를 한 번씩 호출한다면 가능한 실행 경로와 결과도 다양해진다.

- 스레드 1이 94를 얻고, 스레드2가 95를 얻고, lastIdUsed가 95가 된다.
- 스레드 1이 95를 얻고, 스레드2가 94를 얻고, lastIdUsed가 95가 된다.
- 스레드 1이 94를 얻고, 스레드2가 94를 얻고, lastIdUsed가 94가 된다.

<br/>

### 경로 수

`return ++lastIdUsed` 는 바이트 코드 명령 8개에 해당한다.

```java
단계가 N개 이고 스레드가 T개라면 총 단계는 = N*T
각 단계를 실행하기 전 스레드 T개 중 하나를 선택하는 컨텍스트 스위칭이 일어나는데 이로 인해 일련의 순열로 표현 = (NT)!
이때 중복된 순열 수 = N^T
따라서, 가능한 경우의 수 = (NT)! / N^T
```

<br/>

이때 `synchronized` 를 추가하면 가능한 경로의 수는 (스레드가 2개일 때) 2개로 줄어든다.

스레드가 N개라면 가능한 경로의 수는 N! 이다.

```java
public synchronized int incrementValue() {
    return ++lastIdUsed;
}
```

<br/>

### 심층 분석

원자적 연산: 중단이 불가능한 연산

- (int) `lastId = 0;` O
- (long) `lastId = 0;` X
- `++lastId;` X

<br/>

- 프레임: 호출 스택을 정의할 때 사용하는 표준 기법
    - 모든 메서드 호출에는 프레임이 필요하다.
    - 반환 주소, 메서드로 넘어온 매개변수, 메서드가 정의하는 지역 변수 포함
    - 현대 언어는 호출 스택으로 기본 함수/메서드 호출과 재귀적 호출을 지원
- 지역 변수: 메서드 범위 내에 정의되는 모든 변수
    - 정적 메서드를 제외한 모든 메서드는 this라는 지역 변수를 갖는다.
    - this는 현재 객체, 즉 현재 스레드에서 가장 최근에 메시지를 받아 메서드를 호출한 객체를 가리킨다.
- 피연산자 스택: 매개변수를 저장하는 장소
    - 피연산자 스택은 표준 LIFO 자료구조다.

<br/>

### 결론

어떤 연산이 안전하고 안전하지 못한지 파악할 만큼 메모리 모델을 이해하고 있어야 한다.

- 공유 객체/값이 있는 곳
- 동시 읽기/수정 문제를 일으킬 소지가 있는 코드
- 동시성 문제를 방지하는 방법
- …

<br/><br/>

## 라이브러리를 이해하라

### Executor 프레임워크

- 스레드 풀링으로 정교한 실행을 지원
    - 스레드 풀 관리
    - 풀 크기 자동 조정
    - 스레드 재사용
    - Future 지원
        - Future: 여러 개의 독립적인 연산을 실행한 후 모두 끝나기를 기다릴때 활용
    - Runnable/Callable 인터페이스 구현 클래스 지원

→ 스레드를 생성하나 스레드 풀을 사용하지 않거나 직접 생성한 스레드 풀을 사용하는 경우 고려

<br/>

### 스레드를 차단하지 않는 방법

최신 프로세서는 non-blocking 방식으로도 안정적으로 값을 갱신한다.

```java
// Before
public class ObjectWithValue {
	private int value;
	public void synchronized incrementValue() { ++value; }
	public int getValue() { return value;}
}

// After: AtomicXXX 클래스 사용 -> 이전보다 성능 향상
public class ObjectWithValue {
	private AtomicInteger value = new AtomicInteger(0);

	public void incrementValue() { 
		value.incrementAndGet();
	}

	public int getValue() { 
		return value.get();
	}
}
```

<br/>

`After` 가 성능이 더 좋은 이유

→ 현대 프로세서는 보통 CAS 연산을 지원하기 때문

<br/>

- CAS ≒ DB의 낙관적 잠금
    - 여러 스레드가 같은 값을 수정해 문제를 일으키는 상황이 그리 잦지 않다는 가정에서 출발
    - 그래서 그런 상황이 발생했는지 효율적으로 감지해 갱신이 성공할 때까지 재차 시도
- 동기화 ≒ DB의 비관적 잠금
    - synchronized 는 언제나 락을 건다.
    - 자바 버전이 올라갈 수록 내장 락의 성능이 좋아지기는 했지만 그래도 락의 비용은 비싸다.

→ 많은 스레드가 경쟁하는 상황이라도 락을 거는 쪽보다 문제를 감지하는 쪽이 거의 항상 더 효율적

<br/>

CAS 연산은 어떤 메서드가 공유 변수를 갱신하려 든다면, 현재 변수 값이 최종으로 알려진 값인지 확인한다.

그렇다면 변수 값을 갱신하고 아니라면 다른 스레드가 끼어들었다는 뜻이므로 변수 값을 갱신하지 않는다.

값을 변경하려던 메서드는 값이 변경되지 않았다는 사실을 확인하고 다시 시도한다.

<br/>

### 다중 스레드 환경에서 안전하지 않은 스레드

- ex)
    - SimpleDateFormat
    - DB 연결
    - java.util 컨테이너 클래스
    - 서블릿
    - …

<br/>

```java
// containsKey() 와 put() 사이에 다른 스레드가 끼어들어 hashTable에 값을 추가할 수 있는 문제점 존재
if (!hashTable.containsKey(key)) {
	hashTable.put(key, value);
}

// 해결방안 1. HashTable을 잠근다.
synchronized(hashTable) {
	if(!hashTable.containsKey(key))
		hashTable.put(key, value);
}

// 해결방안 2. HashTable을 객체로 감싼 후 다른 API를 사용한다. -> 어댑터 패턴 사용
public class WrappedHashTable(K, V> {
	private Map<K, V> map = new HashTable<K, V>():

	public synchronized void putIfAbsend(K key, V value) {
		if(!hashTable.containsKey(key))
			hashTable.put(key, value);
	}
}

// 해결방안 3. 스레드에 안전한 집합 클래스 사용
ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
map.putIfAbsent(key, value);
```