# 17장. 냄새와 휴리스틱

## 주석

### C1: 부적절한 정보

다른 시스템에 저장할 정보는 주석으로 적절하지 못하다.

보통 작성자, 최종 수정일 SPR 번호 등과 같은 메타 정보만 주석으로 넣는다.

주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.

<br/>

### C2: 쓸모 없는 주석

쓸모 없어질 주석은 아예 달지 않는 편이 가장 좋다.

쓸모 없는 주석은 일단 들어가고 나면 코드에서 쉽게 멀어진다.

코드와 무관하게 혼자서 따로 놀며 코드를 그릇된 방향으로 이끈다.

<br/>

### C3: 중복된 주석

= 코드만으로 충분한데 구구절절 설명하는 주석, 함수 스펙만 기술하는 Javadoc 등

```java
i++;    // i 증가

/**
* @param sellRequest
* @return
* @throws ServiceException
*/
public SellResponse beginSellItem(SellRequest sellRequest) throws ServiceException
```

주석은 코드만으로 다하지 못하는 설명을 부언한다.

<br/>

### C4: 성의 없는 주석

단어를 신중하게 선택한다. 주절대지 않는다. 간결하고 명료하게 작성한다.

<br/>

### C5: 주석 처리된 코드

주석으로 처리된 코드를 발견하면 즉각 지워버린다.

- 더 이상 존재하지 않는 함수를 호출하거나, 이름이 바뀐 변수를 사용하거나, 더 이상 사용하지 않는 표기법을 따르는 등 읽는 사람을 헷갈리게 만든다.

누군가 정말로 필요하다면 이전 버전을 가져오면 된다.

<br/><br/>

## 환경

### E1: 여러 단계로 빌드해야 한다.

빌드는 간단히 한 단계로 끝나야 한다.

온갖 JAR 파일, XML 파일, 기타 시스템에 필요한 파일을 찾지 않도록 해야 한다.

각 요소를 따로 빌드할 필요없이 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

<br/>

### E2: 여러 단계로 테스트해야 한다.

모든 단위 테스트는 한 명령으로 돌려야 한다.

IDE에서 버튼 하나로 모든 테스트를 돌린다면 가장 이상적이다.

모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 중요하다.

<br/><br/>

## 함수

### F1: 너무 많은 인수

한수에서 인수 개수는 작을수록 좋다. 아예 없으면 가장 좋다.

4개 이상은 최대한 피한다.

<br/>

### F2: 출력 인수

일반적으로 인수를 함수 입력으로 해석하기 때문에 함수 인수에는 출력 인수를 사용하지 않는 것이 좋다.

출력 인수를 사용하라고 설계한 변수가 바로 this이기 때문이다.

함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

```java
// AS-IS -> page를 Footer에 붙이는지 Footer에 page를 붙이는지 모호하다.
appendFooter(page);

// TO-BE
page.appendFooter();
```

<br/>

### F3: 플래그 인수

boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.

플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

<br/>

### F4: 죽은 함수

아무도 호출하지 않는 함수는 삭제한다.

<br/><br/>

## 일반

### G1: 한 소스 파일에 여러 언어를 사용한다.

이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

현실적으로는 어려우니 최대한 소스 파일에서 언어 수와 범위를 최대한 줄이도록 한다.

<br/>

### G2: 당연한 동작을 구현하지 않는다.

최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.

- 최소 놀람의 원칙
    - 코드가 읽는 이를 놀라게 해서는 안된다.
    - 표준 코딩 컨벤션을 따르고 주석과 명명이 의미 전달을 잘 해야 하며, 잠재적으로 놀래킬 수 있는 부작용을 최소화 하라.

당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다.

<br/>

### G3: 경계를 올바로 처리하지 않는다.

모든 경계 조건, 모든 구석진 곳, 모든 기벽, 모든 예외는 우아하고 직관적인 알고리즘을 망치는 잠재적인 요소다.

스스로의 직관에 의존하지 마라.

모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.

<br/>

### G4: 안전 절차 무시

serialVersionUID를 직접 제어할 필요가 있을지도 모르지만 그래도 직접 제어는 언제나 위험하다.

컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질지 모르지만 자칫하면 끝없는 디버깅에 시달린다.

실패하는 테스트 케이스를 나중으로 미루는 태도는 위험하다.

<br/>

### G5: 중복

DRY(Don't Repeat Yourself) 법칙 또는 Once and only Once 라고도 한다.

코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.

중복된 코드를 하위 루틴이나 다른 클래스로 분리하라.

추상화 수준을 높이면 구현이 빨라지고 오류가 적어진다.

- 중복 유형
    1. 똑같은 코드가 여러 차례 나오는 중복 → 간단한 함수로 교체
    2. 여러 모듈에서 일련의 switch/case 나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복 → 다형성으로 대체
    3. 알고리즘이 유사하나 코드가 서로 다른 중복 → 템플릿 메소드 패턴이나 전략 패턴으로 중복 제거

<br/>

### G6: 추상화 수준이 올바르지 못하다.

추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다. 혹은 (고차원 개념을 표현하는) 추상 클래스와 (저차원 개념을 표현하는) 파생 클래스를 생성해 추상화를 수행한다.

<br/>

추상화로 개념을 분리할 때는 철저해야 한다.

모든 저차원 개념은 파생 클래스에 넣고, 모든 고차원 개념은 기초 클래스에 넣는다.

세부 구현과 관련한 상수, 변수, 유틸리트 함수는 기초 클래스에 넣으면 안된다. 기초 클래스는 구현 정보를 알아서는 안된다.

```java
public interface Stack {
    Object pop() throws EmptyException;
    void push(Object o) throws FullException;
    double percentFull();    // 올바르지 못한 추상화 <- Stack 구현 방법에 따라 해당 메소드를 구현할 수 없을 수 있다.
}
```

<br/>

### G7: 기초 클래스가 파생 클래스에 의존한다.

개념을 기초 클래스와 파생 클래스로 나누는 이유는 고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장하기 위해서다.

그러므로 기초 클래스가 파생 클래스를 사용한다면 문제가 있다는 말이다.

일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 한다.

(간혹 파생 클래스 개수가 고정된 경우, 기초 클래스에 파생 클래스를 선택하는 코드가 들어간다.)

<br/>

기초 클래스와 파생 클래스를 다른 JAR 파일로 배포하는 편이 좋다.

이렇게 되면 독립적인 개별 컴포넌트 단위로 시스템을 배치할 수 있다.

이는 변경된 컴포넌트만 다시 배치할 수 있어 변경이 시스템에 미치는 영향이 아주 작아지므로 시스템을 유지보수하기가 쉬워진다.

<br/>

### G8: 과도한 정보

잘 정의된 모듈은 인터페이스가 아주 작다. 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다.

부실하게 정의된 모듈은 인터페이스가 난잡하다. 간단한 동작 하나에도 온갖 인터페이스가 필요하다. 반드시 호출해야 하는 온갖 함수를 제공한다. 그래서 결합도가 높다.

<br/>

클래스나 모듈 인터페이스에 노출할 함수를 제한하는게 좋다.

클래스가 제공하는 메소드 수는 작을수록 좋다.

함수가 아는 변수 수도 작을수록 좋다.

클래스에 들어있는 인스턴스 변수 수도 작을수록 좋다.

<br/>

자료, 유틸리티 함수, 상수, 임수 변수를 숨겨라.

메서드나 인스턴스 변수가 넘쳐나는 클래스는 피하라.

하위 클래스에서 필요하다는 이유로 protected 변수나 함수를 마구 생성하지 마라.

<br/>

### G9: 죽은 코드

- 예시
    - 불가능한 조건을 확인하는 if 문
    - throw 문이 없는 try 문에서 catch 블록
    - 아무도 호출하지 하지 않는 유틸리티 함수
    - switch/case 문에서 불가능한 case 조건
    - …

죽은 코드는 설계가 변해도 제대로 수정되지 않기 때문에 오래될수록 악취는 강해진다.

컴파일은 되지만 새로운 규칙이나 표기법을 따르지 않는다.

발견하면 바로 제거하라.

<br/>

### G10: 수직 분리

변수와 함수는 사용되는 위치에 가깝게 정의한다.

지역 변수는 처음으로 사용하기 직전에 선언하며 수직으로 가까운 곳에 위치해야 한다.

비공개 함수는 전체 클래스 범위에 속하더라도 호출한 직후에 정의한다.

<br/>

### G11: 일관성 부족

어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.

- ex)
    - 한 함수에서 `response` 라는 이름으로 `HttpResponse` 인스턴스를 저장했다면 다른 함수에서도 동일한 변수 이름을 사용
    - 한 메서드를 `createPost` 라 명명했다면 다른 메서드도 `deletePost` 등의 유사한 이름을 사용

<br/>

### G12: 잡동사니

소스 파일은 언제나 깔끔하게 정리하라.

- 비어 있는 기본 생성자
- 아무도 사용하지 않는 변수/함수
- 정보를 제공하지 못하는 주석
- …

<br/>

### G13: 인위적 결합

서로 무관한 개념을 인위적으로 결합하지 않는다.

일반적으로 인위적인 결합은 직접적인 상호작용이 없는 두 모듈 사이에서 일어난다.

- ex)
    - enum이 특정 클래스에 속함 → 해당 enum을 사용하는 코드가 특정 클래스를 알아야 한다.
    - 범용 static 함수가 특정 클래스에 속함

뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버린 결과다.

변수, 상수, 함수를 선언할 때는 시간을 들여 올바른 위치를 고민한다.