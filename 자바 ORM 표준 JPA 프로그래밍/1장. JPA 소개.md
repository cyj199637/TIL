# 1장. JPA 소개

## 1.1 SQL을 직접 다룰 때 발생하는 문제점

1. 진정한 의미의 계층 분할이 어렵다.

   → 물리적으로 SQL과 JDBC API를 숨겼더라도 논리적으로는 엔티티와 강한 의존관계를 가지고 있다. 이로 인해 객체를 조회하거나 객체에 필드를 추가할 때도 DAO의 CRUD 코드와 SQL 대부분을 변경해야 한다.

2. 엔티티를 신뢰할 수 없다.

   → 1번 문제로 인해 SQL을 숨겨도 매번 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다.

3. SQL에 의존적인 개발을 피하기 어렵다.

   → DB는 객체를 직접 저장하거나 조회할 수 없다. 따라서 객체를 DB에 CRUD하려면 많은 SQL과 JDBC API를 코드로 변환해야 하고 이를 테이블마다 반복해야 한다.

JPA를 사용하면 객체를 DB에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하지 않고 JPA API를 사용하면 된다.



## 1.2 패러다임의 불일치

: 객체와 RDBMS는 지향하는 목적이 서로 달라 둘의 기능과 표현 방법도 다르다는 것

* DB는 데이터 중심으로 구조화되어 있지만 객체지향의 추상화, 상속, 다형성 같은 개념은 없다.

### 상속

DB 모델링의 슈퍼타입-서브타입 관계를 사용하여 객체 상속과 유사하게 테이블을 설계할 수는 있다. 그러나 해당 객체를 CRUD하려면 슈퍼타입 테이블, 서브타입 테이블 두 곳 모두에 각각 SQL을 작성하거나 조인해야 한다.

JPA를 사용하면 JPA에게 객체를 저장하면 위의 과정을 알아서 해준다.

### 연관관계

객체는 참조를 통해서 관계를 맺는 반면 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다. 따라서 이러한 객체를 DB에 저장하려면 참조 필드를 외래 키 값으로 변환해야 한다. 조회할 때도 DB에서 관련 데이터를 모두 조회하여 각각 객체를 생성한 후, 이 둘 간의 연관관계를 설정해서 반환해야 한다.

JPA를 사용하면 단순히 setter 메소드로 두 객체간의 연관관계를 설정할 수 있으며, 이를 저장하거나 조회할 때 참조-외래 키 간 변환 과정을 알아서 해준다.

### 객체 그래프 탐색

: 참조를 사용해서 연관된 객체를 찾는 것

ex) `member.getOrder().getOrderItem().getItem()...` /  `member.getTeam()`

위의 코드처럼 객체는 어느 방향으로든 getter 메소드로 연관된 객체를 쉽게 찾을 수 있다. 하지만 테이블은 조인을 사용해야 하며 SQL에 따라 객체 그래프 탐색 범위가 제한된다. 그렇다고 해당 객체와 연관된 모든 테이블을 조회할 수는 없으므로 조회 메소드를 상황에 따라 여러 개 만들어야 한다.

JPA를 사용하면 지연 로딩 기능으로 인해 연관된 객체를 신뢰하고 객체처럼 조회할 수 있다.

* 지연 로딩: 연관된 객체를 사용하는 시점에 SELECT SQL을 실행하는 것

### 비교

객체는 동일성 비교(==)와 동등성 비교(equals())가 있다. 그러나 DB는 기본 키로 각 로우를 구분한다. 따라서, 같은 로우를 조회해도 저장되는 인스턴스가 다르기 때문에 객체 측면에서는 다른 객체로 인식한다.

JPA를 사용하면 같은 트랜잭션일 때 같은 객체가 조회되는 것이 보장된다.



## 1.3 JPA란 무엇인가?

: 애플리케이션과 JDBC 사이에서 동작하는 (하이버네이트를 기반으로 만들어진) 자바 진영의 ORM 기술 표준

* ORM (프레임워크): 객체와 RDBMS를 매핑해서 패러다임의 불일치 문제를 대신 해결해주는 것

JPA는 인터페이스를 모아둔 것에 지나지 않기 때문에 JPA를 사용하기 위해서는 JPA를 구현한 ORM 프레임워크를 선택해야 한다. 하지만 JPA 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고 다른 구현 기술로 손쉽게 이동할 수 있다.

### JPA를 사용해야 하는 이유

1. 생산성: 지루하고 반복적인 코드와 SQL을 개발자가 직접 작성하지 않아도 된다.

   → 자바 컬렉션에 객체를 저장하는 것처럼 JPA에 저장할 객체를 전달하면 된다.

2. 유지보수: 엔티티에 변경이 일어나더라도 SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드가 줄어든다.

3. 패러다임의 불일치 해결

4. 성능: 애플리케이션과 DB 사이에서 다양한 성능 최적화를 할 수 있다.

   ex) SELECT SQL은 한 번만 DB에 전달하고 그 이후에는 같은 객체를 재사용

5. 데이터 접근 추상화와 벤더 독립성

6. 표준