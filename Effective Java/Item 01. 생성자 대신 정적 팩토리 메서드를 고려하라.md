## Item 01. 생성자 대신 정적 팩토리 메서드를 고려하라

- 클래스는 public 생성자와 별도로 정적 팩토리 메서드를 제공할 수 있다.

ex) `Boolean` 에서 기본 타입 `boolean` 값을 `Boolean` 객체로 변환해주는 메서드


~~~ java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
~~~



### 정적 팩토리 메서드의 장점

#### 1. 이름을 가질 수 있다.

: 생성자에서는 매개변수와 생성자 자체만으로 어떤 객체를 반환해주는지 파악하기 어렵다. 반면, 정적 팩토리 메서드는 메서드 이름에 제약이 없으니 반환하는 객체의 특성을 살린 이름을 가질 수 있다. 

ex) `BigInteger(int, int, Random)` vs `BigInteger.probablePrime`

또, 생성자는 시그니처에 제약이 있다. 똑같은 타입을 파라미터로 받는 생성자 두개를 만들 수 없기 때문에 그런 경우에도 정적 팩토리 메소드를 사용하는것이 유용하다.



#### 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

: 생성자는 호출할 때마다 새로운 인스턴스를 생성해서 반환하지만 불변 클래스인 경우나 매번 새로운 객체를 만들 필요가 없는 경우에 정적 팩토리 메서드로 미리 만들어둔 인스턴스 또는 캐시해둔 인스턴스를 반환할 수 있다. (특히 생성 비용이 큰) 같은 객체가 자주 요청되는 상황이라면 이를 통해 성능을 향상 시킬 수 있다.

이런 방식으로 정적 팩토리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지 통제할 수 있는데, 이런 클래스를 인스턴스 통제 클래스라 한다.

- 인스턴스를 통제하는 이유?
  - 싱글톤 객체로 만들 수 있다.
  - 클래스의 인스턴스화를 막을 수 있다.
  - 불변 값 클래스에서 동치인 인스턴스가 하나임을 보장할 수 있다.



#### 3. 반환 타입의 하위 타입 객체를 반환할 수 있다.

: 클래스에서 만들어 줄 객체의 클래스를 선택하는 유연함이 있다. API를 만들 때 이를 응용하여 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다. 즉, 리턴 타입의 하위 타입의 인스턴스를 만들어줘도 되니까, 리턴 타입은 인터페이스로 지정하고 그 인터페이스의 구현체는 API로 노출 시키지 않지만 그 구현체의 인스턴스를 만들어 줄 수 있다는 말이다.

이렇게 구현하면 public으로 제공해야 하는 API의 수를 줄일 수 있고, 개발자들이 해당 API를 사용할 때 알아야 할 개념의 수와 난이도를 낮출 수 있다.



#### 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

: 3과 같은 이유로 리턴 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다. `EnumSet` 클래스는 생성자 없이 public 정적 팩토리 메소드, `allOf()`, `of()` 등을 제공한다. 그 안에서 리턴하는 객체의 타입은 enum 타입의 개수에 따라 `RegularEnumSet` 또는 `JumboEnumSet`으로 달라진다.

이런 객체 타입은 노출하지 않고 감춰져 있기 때문에 추후에 JDK의 변화에 따라 새로운 타입을 만들거나 기존 타입을 없애도 문제가 되지 않는다.



#### 5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

: 이러한 유연성을 제공하는 정적 팩토리 메소드는 `서비스 프로바이더` 프레임워크의 근본이다.

* `서비스 프로바이더` 프레임워크 / ex) `JDBC`

  * `서비스 인터페이스` : 서비스의 구현체를 대표 / `Connection`

  * `프로바이더 등록 API` : 구현체를 등록하는데 사용 / `DriverManager.registerDriver()`

  * `서비스 엑세스 API` : 클라이언트가 해당 서비스의 인스턴스를 가져갈 때 사용 / `DriverManager.getConnection()`

  * `서비스 프로바이더 인터페이스` : `서비스 인터페이스` 의 인스턴스 제공 / `Driver`

    ​													(없는 경우, 리플랙션을 사용해서 구현체 생성)

자바 6부터는 `java.util.ServiceLoader`라는 일반적인 용도의 서비스 프로바이더를 제공되어 프레임워크를 직접 만들 필요가 거의 없어졌다.



### 정적 팩토리 메서드의 단점

#### 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다.

: 즉, public 또는 protected 생성자 없이 정적 팩토리 메소드만 제공하는 클래스는 상속할 수 없다. 그러나 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다.



#### 2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다.

생성자는 Javadoc 상단에 모아서 보여주지만 static 팩토리 메소드는 API 문서에서 특별히 다뤄주지 않는다. 따라서 클래스나 인터페이스 문서 상단에 팩토리 메소드에 대한 문서를 제공하는 것이 좋겠다.