## Item 10. equals는 일반 규약을 지켜 재정의하라

### equals()를 재정의하지 않는 것이 나은 경우

`equals()`를 잘못 재정의하면 끔찍한 결과를 초래한다. 따라서 다음 상황 중 하나에 해당한다면 재정의하지 않는 것이 좋다.

* 각 인스턴스가 본질적으로 고유하다.

  : 값을 표현하는 클래스가 아닌 동작하는 개체를 표현하는 클래스인 경우 ex) `Thread`

* 인스턴스의 논리적 동치성을 검사할 일이 없다.

  * 논리적 동치성: 표현하는 방식은 다르지만 같은 의미를 담고 있는 관계

    ex) `Pattern` 처럼 `equals()`로 두 인스턴스가 같은 정규표현식을 나타내는지 검사하는 경우

* 상위 클래스에서 재정의한 `equals()` 하위 클래스에도 딱 들어맞는다.

* 클래스가 pricate이거나 package-private이고 `equals()` 를 호출할 일이 없다.

* 대상 클래스가 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스거나 `Enum` 이다.



### equals()를 재정의해야 하는 경우

객체 식별성이 아닌 논리적 동치성을 확인해야 하는데, 상위 클래스의 `equals()` 는 논리적 동치성을 비교하지 않을 때다. 주로 `Integer` 나 `String` 같은 값 클래스들이 여기 해당한다. `equals()` 로 객체가 같은지가 아닌 값이 같은지를 확인하도록 재정의해두면 논리적 동치성 비교는 물론 `Map` 의 키와 `Set` 원소로 사용할 수 있게 된다.



### equals()를 재정의할 때 지켜야하는 규약

다음은 `Object` 명세에 적힌 규약이다.컬렉션 클래스들을 포함한 많은 클래스들은 전달받은 객체가 이 규약을 지킨다고 가정하고 동작하므로 이 규약을 잘 지키며 재정의해야 한다.

> `equals()` 는 동치관계를 구현하며, 다음을 만족한다.
>
> #### 반사성
>
> null이 아닌 모든 참조 값 x에 대해, `x.equals(x)` 는 true다.
>
> 
>
> #### 대칭성
>
> null이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)` 가 true면 `y.equals(x)` 도 true다. 
>
> 
>
> #### 추이성
>
> null이 아닌 모든 참조 값 x, y, z에 대해, `x.equals(y)` 가 ture이고 `y.equals(z)`도 true면 `x.equals(z)` 도 true다.
>
> 
>
> #### 일관성
>
> null이 아닌 모든 참조 값 x, y에 대해, `x.quals(z)` 를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
>
> 
>
> #### null 아님
>
> null이 아닌 모든 참조 값 x에 대해, `x.equals(null)` 은 false다.