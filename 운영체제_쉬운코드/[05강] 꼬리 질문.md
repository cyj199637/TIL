## 1. **Java는 synchronized 키워드를 이용해 이미 동시성 제어가 가능한데 Atomic 클래스를 왜 제공하는걸까?**

(참고: [https://lights93.github.io/java/java-optimization-chap12/#126-최신-자바-동시성](https://lights93.github.io/java/java-optimization-chap12/#126-%EC%B5%9C%EC%8B%A0-%EC%9E%90%EB%B0%94-%EB%8F%99%EC%8B%9C%EC%84%B1))

### synchronized

기존 `synchronized` 키워드는 여러 한계점이 노출되었다.

- 락이 걸린 객체에서 일어나는 동기화 작업은 모두 균등하게 취급됨
  (쓰기 작업에만 `synchronized` 를 적용하면 소실된 업데이트 현상이 나타남)
- 락 획득/해제는 반드시 메서드 수준이나 메서드 내부의 동기화 블록 안에서 이루어져야 함
- 락을 얻지 못한 스레드는 블로킹됨
    - 락을 얻지 못할 경우, 락을 얻어 처리를 계속하려는 시도조차 불가능
    - 멀티 스레드 환경에서 특정 스레드가 해당 블록 전체를 잠그기 때문에 다른 스레드는 아무런 작업을 하지 못하고 기다리게 됨
- 락을 획득하고 해제하는 작업 자체가 비용이 많이 드는 작업

<br/>

### Atomic 클래스

위의 문제점을 해결하고 non-blocking 하면서 동기화 문제를 해결하기 위해 고안된 방법이 Atomic 클래스이다.

Atomic 클래스는 동기화가 되어 있는 변수를 제공하며, 변수를 사용하면 `synchronized` 를 메소드에 지정할 필요가 없다.

특히 Atomic 클래스는 CAS 알고리즘을 이용하기 때문에 `synchronized` 보다 효율적으로 동시성을 보장한다.

- 멀티 스레드 환경에서 쓰기 작업도 가능
- CAS(compare-and-swap) 알고리즘
    - 멀티 스레드 환경에서 직렬화를 이루기 위한 원자적인 연산
    - 예상되는 현재 값과 원하는 새 값, 그리고 메모리 위치(포인터)를 전달받아 다음 두 가지 일을 한다.
        1. 예상되는 현재 값(Compared value)을 메모리 위치에 있는 데이터(Destination)와 비교
        2. 두 값이 일치하면 현재 값을 원하는 새 값(Exchanged value)으로 교체

![CAS 알고리즘](./image/img_14.png)

<br/><br/>

## 2. **세마포어는 여러 스레드/프로세스가 공유자원에 접근할 수 있게 되면 크리티컬 섹션의 정의가 무너지는 것이 아닐까?**

## 3. **세마포어는 여러 스레드/프로세스가 공유자원에 접근할 수 있게 하면서 어떻게 상호 배제를 지키는걸까?**