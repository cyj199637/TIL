## 1. User mode vs Kernel mode

참고

[https://hongong.hanbit.co.kr/운영체제란-커널의-개념-응용-프로그램-실행을-위한/](https://hongong.hanbit.co.kr/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80-%EC%BB%A4%EB%84%90%EC%9D%98-%EA%B0%9C%EB%85%90-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89%EC%9D%84-%EC%9C%84%ED%95%9C/)

[https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/?ref=gcse](https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/?ref=gcse)

<br/>

### 커널

> 운영체제의 핵심 서비스를 담당하는 부분

- 핵심 서비스

  - 자원에 접근하고 조작하는 기능
  - 프로그램이 올바르고 안전하게 실행되게 하는 기능

커널은 사용자가 실행하는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.

만약 응용 프로그램이 CPU, 메모리, 하드 디스크 등에 마음대로 접근하고 조작할 수 있다면 자원이 무질서하게 관리될 것이고, 응용 프로그램이 조금만 실수해도 컴퓨터 전체에 큰 악영향을 끼칠 수 있기 때문이다.

따라서, 커널은 응용 프로그램들이 자원에 접근하려고 할 때 오직 자신을 통해서만 접근하도록 하여 자원을 보호한다.

→ 이중 모드 방식으로 보호

- **이중 모드**: CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식

<br/>

### 사용자 모드

> 운영체제 서비스를 제공받을 수 없는 실행 모드

→ 커널 영역의 코드를 실행할 수 없는 모드

일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행된다.

그러나 사용자 모드로 실행 중인 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근하는 명령어를 실행할 수 없다.

따라서, 사용자 모드로 실행되는 일반적인 응용 프로그램은 자원에 접근할 수 없다.

<br/>

### 커널 모드

> 운영체제 서비스를 제공받을 수 있는 실행 모드

→ 커널 영역의 코드를 실행할 수 있는 모드

CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있다.

- 커널 모드는 사용자 모드에 비해 더 많은 권한을 갖는다.
- 커널 모드는 사용자 프로그램과 커널 프로그램 모두 접근할 수 있으므로 제한이 없다.

운영체제는 커널 모드로 실행되기 때문에 자원에 접근할 수 있다.

<br/>

|                                                      | Kernel mode | User mode |
|------------------------------------------------------| --- | --- |
| Access to Resources                                  | 커널 모드에서는 시스템 리소스에 접근하는데 아무런 제한이 없다. | 사용자 모드에서는 시스템 리소스에 직접 접근할 수 없다. 리소스에 접근하려면 시스템 콜을 통해 요청해야 한다.
|
| Interruptions                                        | 커널 모드에서 인터럽트가 발생하면 전체 운영 체제가 다운될 수 있다. | 사용자 모드에서 인터럽트가 발생하면 단일 프로세스가 실패한다.   |
| Virtual address space                                | 커널 모드에서 모든 프로세스는 단일 가상 주소 공간을 공유한다. | 사용자 모드에서 모든 프로세스는 별도의 가상 주소 공간을 얻는다. |
| Mode bit value (CPU가 현재 어떤 모드로 작동하고 있는지 판단할 수 있는 플래그) | mode bit 0 | mode bit 1 |
| Memory References                                    | 커널 모드, 사용자 모드 모두의 메모리 영역을 참조할 수 있다. | 사용자 모드에 할당된 메모리만 참조할 수 있다.  |
| System Crash                                         | 커널 모드의 시스템 충돌은 리스크가 크고 상황을 더욱 복잡하게 만든다. | 사용자 모드에서는 세션을 재개하여 간단히 시스템 충돌을 복구할 수 있다. |
| Access                                               | 필수 기능만 커널 모드에서 작동하도록 허용된다. | 사용자 프로그램은 유저 모드에서 접근하고 실행할 수 있다. |

<br/><br/>

## 2. **시스템 콜도 인터럽트의 한 종류라고 볼 수 있는가?**
(참고: https://baebalja.tistory.com/m/354)

### 인터럽트

> CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있도록 하는 것

<br/>

**CPU가 다른 프로세스를 실행하는 동안 다른 장치로부터 발생하는 이벤트들을 처리하는 방법:**

- 폴링
    - 대상을 주기적으로 감시하여 상황이 발생하면 해당 처리 루틴을 실행
    - 주기적으로 CPU가 상태를 파악하기 위해 장치의 레지스터를 읽어야 함

      → 하드웨어 작업이 완료할 때까지 다른 프로세스/스레드에게 CPU를 넘기지 않고 계속해서 상태를 확인하기 때문에 CPU를 낭비하게 됨

    - 빠른 하드웨어라면 폴링이 더 유리

      → 인터럽트도 결국 컨텍스트 스위칭이 일어나는 작업이고, 컨텍스트 스위칭의 비용은 크므로 한 두번의 폴링으로 끝날 정도의 속도의 하드웨어라면 폴링이 더 효율적

- 인터럽트
    - 상대가 CPU에게 일을 처리해 달라고 요청
    - 신호가 올 때만 처리하므로 CPU 자원을 적게 사용
    - 느린 하드웨어에서 유리

<br/>

**처리 과정:**

1. CPU는 인터럽트를 감지하면 모든 작업을 중단
2. 중단된 작업의 위치(PC), 레지스터 상태 등을 PCB에 저장
3. 발생한 인터럽트를 위한 ISR가 저장된 주소를 IDT에서 찾아 점프하여 수행
    - IDT(Interrupt Descriptor Table): 인터럽트 혹은 exception 핸들러들의 정보를 저장하는 구조체
    - ISR(Interrupt Service Routine): 인터럽트 처리를 위한 프로그램
4. 처리가 끝나면 ISR의 반환 값과 함께 스택에 저장했던 작업 상태를 복구하고 작업을 다시 실행

<br/>

**종류:**

- 하드웨어 인터럽트(Hardwear Interrupt)

  → 인터럽트가 컨트롤러 등 하드웨어 장치에 의해 CPU 외부에서 발생

    - 종류
        - 타이머 인터럽트
            - 프로세스/스레드가 할당된 CPU time을 모두 사용했을 때 발생

              → 컨텍스트 스위칭이 일어남

        - I/O 인터럽트
            - 입출력 장치에 의해서 발생
        - 전원 이상 인터럽트
- 소프트웨어 인터럽트(Softwear Interrupt)

  → 인터럽트가 CPU에서 돌아가고 있는 프로그램에 의해 CPU 내부에서 발생

    - 종류
        - 예외(Exception)
            - 비정상적인 작업 시도나 메모리 바깥 접근 등 권한 없는 작업 시도할 때 발생

              → CPU가 명령어를 수행하다가 처리할 수 없는 예외상황을 만나면 자기 자신을 인터럽트 걸어서 커널의 처리루틴으로 점프

        - 시스템 콜(System Call)
            - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스 요청