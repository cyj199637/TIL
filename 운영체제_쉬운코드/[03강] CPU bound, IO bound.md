# [03강] CPU bound, I/O bound
(강의 자료 링크: https://www.youtube.com/watch?v=qnVKEwjG_gM)

## 용어 정리

### CPU

프로세스의 명령어를 해석하고 실행하는 장치

<br/>

### I/O

- 파일을 읽고 쓰는 것
- 네트워크의 어딘가와 데이터를 주고 받는 것
- 입출력 장치와 데이터를 주거나 받는 것

<br/>

### 버스트(burst)

어떤 현상이 짧은 시간 안에 집중적으로 일어나는 일

<br/>

### CPU 버스트

프로세스가 CPU에서 한 번에 연속적으로 실행되는 시간

→ 메모리에 올라가있는 프로세스가 자신의 차례가 되어서 CPU에서 실행됐을 때 자신의 명령어들이 CPU에서 연속적으로 실행된 시간

<br/>

### I/O 버스트

프로세스가 I/O 작업을 요청하고 결과를 기다리는 시간

<br/><br/>

## 프로세스와 버스트

프로세스의 인생은 CPU 버스트와 I/O 버스트의 연속이다.

<br/>

### CPU 버스트 길이에 따른 빈도

![Untitled](./image/img_09.png)

→ 대부분의 프로세스들의 CPU 버스트가 8ms 내로 끝난다.

<br/><br/>

## CPU bound 프로세스

CPU 버스트가 많은 프로세스

ex) 동영상 편집 프로그램, 머신러닝 프로그램 등 → 연산 작업이 많은 프로그램

<br/>

### CPU bound 프로그램과 스레드 수

듀얼 코어 CPU에서 동작할 CPU bound 프로그램을 구현한다면 몇 개의 스레드를 쓰는게 좋을까?

→ CPU bound 프로그램에서 적절한 스레드 수 = CPU 수 + 1 (recommended by Goetz)

<br/>

why? 컨텍스트 스위칭 때문

→ 컨텍스트 스위칭은 스레드의 실행과 상관없는 추가적인 오버헤드로, 오직 스위칭만을 위해 CPU를 낭비하는 작업이기 때문

![Untitled](./image/img_10.png)

<br/><br/>

## I/O bound 프로세스

I/O 버스트가 많은 프로세스

ex) (일반적인) 백엔드 API 서버

- 특히 DB나 캐시 서버에 데이터를 요청하는 작업
- 해당 작업은 네트워크를 타는 작업이므로 CPU에서 몇 십개의 명령어를 처리하는 것보다 오래 걸림

<br/>

### I/O bound 프로그램과 스레드 수

I/O bound 프로그램을 구현한다면 몇 개의 스레드를 쓰는게 좋을까?

→ 여러 상황에 맞춰서 적절한 스레드 수를 찾아야 함

만약 API 서버가 thread per request 방식이라면?

- 몇 개의 스레드들을 미리 만들어 놓을지 여러 상황을 고려해서 결정하는 것이 필요
- ex)
    - API 서버의 하드웨어 스펙
    - 애플리케이션의 I/O 버스트 비중이 대략 어느 정도인지
    - 예상되는 트래픽의 패턴은 어떤지
    - …

<br/><br/><br/>

---
## QnA

### 1. 컨텍스트 스위칭 되는 시간은 CPU 사용률에 포함되지 않는 것인가?

어차피 스레드가 blocking I/O 호출을 했을 때 해당 스레드가 블로킹되어 컨텍스트 스위칭이 일어나면서 다른 스레드가 해당 CPU에 할당이 되고, 그렇게 되면 CPU는 쉬는 시간이 없으니 늘 사용률 100% 아닌가?

<br/>

--->>>

일반적으로 CPU 사용률에는 컨텍스트 스위칭에 사용되는 CPU time도 포함된다.

실제로 `다른 스레드가 해당 CPU에 할당이 되고, 그렇게 되면 CPU는 쉬는 시간이 없으니 늘 사용률 100% 아닌가?` 의 상황이 발생할 수 있다.

- ex) 오직 CPU만 사용하는, 즉 I/O 작업은 하나도 없는 네 개의 스레드를 듀얼 코어 환경에서 실행시키는 상황

  (사실 이 경우에는 듀얼 코어기 때문에 세 개 혹은 두 개의 스레드만 사용해도 CPU 사용률은 100%이다.)

<br/>

하지만 보통 백엔드 서버 같은 경우에는 다른 양상을 보인다.

자바를 기준으로, 만약 API 요청 당 하나의 스레드가 할당되는 방식으로 서버가 동작한다면, 그 하나의 요청에는 DB나 Cache에 접근해서 데이터를 읽어오는 네트워크 I/O 작업들이 수반되는데, 이때 I/O 작업 한 번 하는 시간 동안 CPU에서는 훨씬 많은 CPU 명령어들을 수행할 수 있다.

그래서 보통 백엔드 서버 애플리케이션은 I/O bound의 경향을 띄게 되고, 그렇기 때문에 코어 수보다 더 많은 스레드를 사용한다고 무조건 CPU 사용률이 100%가 되진 않는다.

<br/>

여기서 더 중요한 점은 백엔드 서버의 경우 CPU 사용률을 100%가 되게 해서도 안된다는 것이다.

서버 CPU 사용률 100%의 의미가 해당 서버의 최대 능력치에 딱 맞게 일하고 있다는 뜻인지 아니면 해당 서버의 최대 능력치를 벗어나 매우 많은 일이 몰려서 서버가 과부하 상태로 일하고 있다는 것인지 구분할 수 없기 때문이다.

보통은 과부하 상태를 의미할 가능성이 크고, 이는 많은 작업량으로 요청 처리가 늦어지면서 서비스가 제대로 동작하지 않는다는 뜻이며, 서비스 사용자들에게 좋지 않은 경험을 주게 된다.

따라서, 회사마다 기준은 다르겠지만 백엔드 서버의 CPU 사용률이 100%를 넘기지 않게 운영해야한다.