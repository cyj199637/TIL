# [06강] 모니터
(강의 자료 링크: https://www.youtube.com/watch?v=Dms1oBmRAlo)

## 모니터(monitor)

- mutual exclusion을 보장
- 조건에 따라 스레드가 대기 상태로 전환하는 기능을 제공

<br/>

### 모니터는 언제 사용되나?

- 한 번에 하나의 스레드만 실행되어야 할 때
- 여러 스레드와 협업이 필요할 때

<br/>

### 구성 요소

- `mutex`

  : critical section에서 mutual exclusion을 보장하는 장치

    - critical section에 진입하려면 mutex lock을 취득해야 함
    - mutex lock을 취득하지 못한 스레드는 큐에 들어간 후 대기 상태로 전환
    - mutex lock을 쥔 스레드가 lock을 반환하면 락을 기다리며 큐에 대기 상태로 있던 스레드 중 하나가 실행됨
- `condition variable(s)`
    - waiting queue 를 가짐
        - waiting queue: 조건이 충족되길 기다리는 스레드들이 대기 상태로 머무는 곳
    - 주요 동작
        1. wait: thread가 자기 자신을 condition variable의 waiting queue에 넣고 대기 상태로 전환
        2. signal: waiting queue에서 대기 중인 스레드 중 하나를 깨움
        3. broadcast: waiting queue에서 대기 중인 스레드 전부를 깨움

<br/>

### 동작 원리

```java
    acquire(m);                       // 모니터의 락 취득

    while(!p) {
	    wait(m, cv);              // 조건 충족 안되면 waiting
    }                                 // -> condition value가 관리하는 waiting queue에 자기 자신을 넣고, 자신의 상태를 대기 상태로 전환함

    ...

    signal(cv2); or broadcast(cv2);   // cv2가 cv와 같을 수도 있음

    release(m);                       // 미터의 락 반환
```

- `wait()` 에 mutex가 들어가는 이유

  → 대기 상태로 전환된 스레드는 락을 쥐고 있으면 안된다.

  왜냐하면 언제 깨어날지도 모를 뿐더러 락을 계속 쥐고 있으면 다른 스레드들이 critical section에 진입할 수 없기 때문이다.

  따라서, `wait()` 를 실행하는 스레드는 락을 반환을 해야하며, 나중에 깨어나게 되면 락을 다시 취득하여 mutual exclusion이 보장된 채로 로직을 실행해야 한다.

- critical section의 로직을 수행하면서 조건을 충족하면 waiting queue에서 `signal()` 혹은 `broadcast()` 로 스레드를 깨운다.
    - 여기서 주의할 점, signal과 broadcast에 의해 상태가 전환된 스레드들은 entry queue에 있는 스레드들 보다 우선적으로 락을 얻는 것이 아니라 다시 entry queue로 돌아가서 똑같이 차례를 기다린다.

<br/>

### 모니터가 가지는 두 개의 큐

1. entry queue: critical section에 진입을 기다리는 큐
2. waiting queue: 조건이 충족되길 기다리는 큐

<br/><br/>

## bounded producer/consumer problem

- 버퍼에 아이템을 넣을 공간이 없을 때, producer 가 계속해서 버퍼의 여유 공간을 확인해야 하는가?
- 버퍼가 비어있을 때, consumer 가 계속해서 버퍼에 아이템이 있는지 없는지 확인해야 하는가?

![Untitled](./image/img_15.png)

```java
global volatile Buffer q;    // critical section에서 mutual exclusion이 보장될 수 있도록 사용되어야 함.
                             // 그렇지 않으면 race condition이 발생할 수 있음 
global Lock lock;            // 모니터가 가지고 있는 뮤텍스 락
global CV fullCV;
global CV emptyCV;
```

```java
public method producer() {
	while (true) {
		task myTask = ...;

		lock.acquire();

		while(q.isFull()) {
			wait(lock, fullCV);
		}

		q.enqueue(myTask);

		signal(emptyCV); or broadcast(emptyCV);    // consumer 스레드들을 깨움

		lock.release();
	}
}
```

```java
public method consumer() {
	while (true) {
		lock.acquire();

		while(q.isEmpty()) {
			wait(lock, emptyCV);
		}

		myTask = q.dequeue();

		signal(fullCV); or broadcast(fullCV);    // producer 스레드들을 깨움

		lock.release();

		doStuff(myTask);
	}
}
```

<br/><br/>

## 자바에서 모니터란

자바에서 모든 객체는 내부적으로 모니터를 가진다.

모니터의 mutual exclusion 기능은 synchronized 키워드로 사용한다.

자바의 모니터는 condition variable을 하나만 가진다.

자바 모니터를 사용할 때 두 가지 이상의 condition variable이 필요하다면 따로 구현해야 한다.

<br/>

### 자바 모니터의 세 가지 동작

- wait
- notify → signal
- notifyAll → broadcast

<br/><br/>

## bounded producer/consumer problem with JAVA

```java
// 각 메소드에 사용된 wait(), notifyAll()은 객체 자신의 condition variable에 대한 동작들이다.
class BoundedBuffer {
	private final int[] buffet = new int[5];
	private int count = 0;

	public synchronized void produce(int item) {
		while (count == 5) {
			wait();
		}

		buffer[count++] = item;
		notifyAll();             // 객체에는 하나의 condition variable만 있어
                             // 위의 예제와 달리 producer와 consumer의 스레드들을 구분해서 깨울 수 없으므로 모든 스레드들을 깨운다.
	}

	public void consume() {
		int item = 0;
		synchronized (this) {    // -> 객체 자신의 뮤텍스 락을 쥐고 진입하라
			while (count == 0) {
				wait();
			}

			item = buffer[--count];
			notifyAll();
		}

		System.out.println("Consume: " + item);
	}
}
```

```java
public class Main {
	public static void main(String[] args) throws {
		BoundedBuffer buffer = new BoundedBuffer();

		Thread consumer = new Thread(() -> {
			buffer.consume();
		});

		Thread producer = new Thread(() -> {
			buffer.produce(100);
		});

		consumer.start();
		producer.start();

		consumer.join();
		producer.join();
		System.out.println("완료");
	}
}
```