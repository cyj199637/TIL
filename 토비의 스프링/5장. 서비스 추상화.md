# 5장. 서비스 추상화

## 5.2 트랜잭션 서비스 추상화

### 5.2.2 트랜잭션 경계설정

* 트랜잭션의 경계: 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치
* 트랜잭션의 경계설정: setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 							       종료하는 작업
* 로컬 트랜잭션: 하나의 DB 커넥션 안에서 만들어지는 트랜잭션

JDBC의 트랜잭션의 시작과 종료는 Connection 오브젝트를 통해 이뤄진다. 현재 코드로는 UserService의 같은 메서드에 속해있는 DB 작업이더라도 각각 UserDao의 메서드를 호출하여 JdbcTemplate을 통해 각자 별도의 Connection 오브젝트를 얻게 된다. 결국 트랜잭션은 Connection 오브젝트 기반이므로 DAO 메서드를 호출할 때마다 새로운 트랜잭션이 만들어지게 된다.

→ 트랜잭션의 경계설정 작업을 UserService 쪽으로 가져와야 한다.

하지만 단순히 트랜잭션 경계설정 코드를 UserService 쪽으로 가져오게 되면 트랜잭션의 시작과 종료를 위해 Connection 오브젝트의 생성/종료 코드도 가져와야 하며, DAO 메서드에서 같은 Connection을 사용하게끔 DAO 메서드를 호출할 때마다 Connection 객체를 파라미터로 전달해줘야 한다.

<문제점>

* JdbcTemplate 활용 불가
* DAO 메서드와 비즈니스 로직을 담고 있는 UserService의 메서드에 Connection 파라미터가 추가되야 함
  * UserService가 싱글톤이라 멀티스레드 환경까지 고려한다면 UserService의 인스턴스 변수에 Connection 오브젝트를 저장할 수도 없음
* DAO 메서드가 Connection 파라미터를 받게 된다면 UserDao는 데이터 액세스 기술에 독립적일 수 없음
* DAO 메서드가 Connection 파라미터를 받게 된다면 테스트 코드에도 영향을 미침



### 5.2.3 트랜잭션 동기화

: 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO 메서드에서 저장된 Connection을 가져다가 사용하는 것

![그림 5-3 트랜잭션 동기화 이미지 검색결과](../images/transation.png)

1. Connection 생성
2. 생성한 Connection을 트랜잭션 동기화 저장소에 저장 + 트랜잭션 시작
3. DAO 메서드 호출
4. JdbcTemplate 메서드에서 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection이 있는지 확인
5. 있다면 해당 Connection을 이용해 쿼리 실행
   * 없다면 JdbcTemplate이 직접 DB 커넥션을 만들어 트랜잭션을 시작
   * 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 땐 JdbcTemplate은 Connection을 닫지 않는 채로 작업 종료

12. 트랜잭션 내의 모든 작업이 정상적으로 끝나면 Connection의 commit()을 호출해서 트랜잭션을 완료
13. 트랜잭션 저장소에서 해당 Connection을 제거

**트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리**하므로 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 나지 않는다.



### 5.2.4 트랜잭션 서비스 추상화

위의 방법은 한 가지 문제점을 가지고 있다. 바로 JDBC 트랜잭션 API와 JdbcTemplate과 동기화하는 API로 인해 JDBC DAO에 의존하게 된다는 것이다. 만약 여러 개의 DB를 사용하기 위해 글로벌 트랜잭션 방식을 사용해야 되거나 JPA/하이버네이트 등으로 데이터 액세스 기술이 변경된다면 UserService의 코드까지 같이 변경해야 한다.

* 글로벌 트랜잭션: 여러 개의 DB가 참여하는 트랜잭션

이 문제를 해결하기 위해 스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 이를 이용하면 기술에 종속되지 않은 채 일관된 방식으로 트랜잭션을 제어하는 트랜잭션 경계설정 작업이 가능해진다.

![그림 5-6 스프링의 트랜잭션 추상화 계층 이미지 검색결과](../images/img.png)

* **PlatformTransactionManager**: 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스





## 5.3 서비스 추상화와 단일 책임 원칙

애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다. DI의 가치는 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

스프링 DI가 없었다면 인터페이스를 도입해서 추상화를 했더라도 아래 코드와 같이 적지 않은 코드 사이의 결합이 남아있게 된다. 

~~~ java
public class UserService {
    ...
    PlatformTransactionManager transactionManager =
        new DataSourceTransactionManager(dataSource);	// 결합이 남아있음
}
~~~

DI를 통해 PlatformTransactionManager의 생성과 의존관계 설정을 스프링에 맡긴 덕에 완벽하게 트랜잭션 기술에서 자유로운 UserService를 가질 수 있게 되었다.

단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않으며 같은 이유로 단일 책임에 집중되는 응집도가 높은 코드를 작성할 수 있다.