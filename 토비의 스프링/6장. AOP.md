# 6장. AOP

## 6.1 트랜잭션 코드의 분리

### 6.1.2 DI를 이용한 클래스의 분리

**DI의 기본 아이디어는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하는 것이다.**

→ 구현 클래스를 얼마든지 외부에서 변경 가능

#### 트랜잭션 경계설정 코드 분리의 장점

* 비즈니스 로직을 담당하고 있는 클래스의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에 신경 쓰지 않아도 됨

  → 트랜잭션은 DI를 이용해 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만 하면 됨

* 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있음





## 6.2 고립된 단위 테스트

<작은 단위의 테스트가 좋은 이유>

* 테스트가 실패했을 때 그 원인을 찾기 쉽다.
* 테스트의 의도나 내용이 분명해진다.
* 만들기 쉽다.



### 6.2.1 복잡한 의존관계 속의 테스트

테스트 대상 클래스만 테스트하는 것처럼 보이지만 대상 클래스와 의존 관계를 맺고 있는 오브젝트, 이들과 관련된 다른 오브젝트, 환경, 서비스, 서버, 네트워크까지 함께 테스트하게 된다.

<문제점>

* 테스트를 준비하기 힘들다
* 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수 있다.
* 수행 속도가 느리며 그에 따라 테스트를 작성하고 실행하는 빈도가 떨어질 수 있다.

따라서, 테스트의 대상이 환경이나 외부 서버, 다른 클래스의 코드에 영향을 받지 않도록 고립시켜야 한다.

→ Mock 오브젝트로 의존 관계에 있는 오브젝트를 대체

* Mock 오브젝트는 기본적으로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다.



### 6.2.3 단위 테스트와 통합 테스트

* 단위 테스트: 테스트 대상 클래스를 Mock 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사					 용하지 않도록 고립시켜서 테스트 하는 것
* 통합 테스트: 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나 외부의 DB나 파일, 					서비스 등의 리소스가 참여하는 테스트

#### 가이드라인

* 항상 단위 테스트를 먼저 고려한다.
* 하나의 클래스나 성격과 목적이 같은 클래스 몇 개를 모아서 외부와의 의존관계를 모두 차단하고 필요에 따라 스텁이나 Mock 오브젝트 등의 테스트 대역을 이용하도록 테스트를 만든다.
* 외부 리소스를 사용해야만 가능한 테스트는 통합 테스트로 만든다.
* 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만, 단위 테스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
* 단위 테스트를 만들기가 너무 복잡하다고 판단되는 코드는 처음부터 통합 테스트를 고려해본다.
* 스프링 테스트 컨텍스트 프레임워크를 이용하는 테스트는 통합 테스트다.





## 6.3 다이내믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

* **프록시**: 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것
  * 타깃과 같은 인터페이스를 구현했다.
  * 프록시가 타깃을 제어할 수 있는 위치에 있다.
  * 목적1: 클라이언트가 타깃에 접근하는 방법을 제어하기 위해 → 프록시 패턴
  * 목적2: 타깃에 부가적인 기능을 부여해주기 위해 → 데코레이터 패턴
* **타깃 or 실체**: 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트

#### 프록시 적용 과정

* 분리된 부가기능을 담은 클래스는 이 외의 나머지 모든 기능을 원래 핵심기능을 가진 클래스로 위임해줘야 한다.

  → 핵심기능 클래스는 부가기능 클래스의 존재 자체를 모르기 때문에 부가기능이 핵심기능을 사용하는 구조가 된다.

* 위와 같이 구성하더라도 클라이언트가 핵심기능 클래스를 직접 사용하면 부가기능이 적용될 기회 자체가 없어진다. 따라서, 부가기능 클래스는 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐 핵심기능을 사용하도록 만들어야 한다.

  → 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 클래스는 핵심기능 클래스의 인터페이스를 구현하여 그 사이에 끼어들어야 한다.

* 부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.

![img](../images/img.png)



#### 데코레이터 패턴

: 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴

* `다이내믹하게 기능을 부가한다` : 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 												   있지 않다는 뜻

* 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용

* 프록시가 꼭 한 개로 제한되지 않는다.

  * 여러 개라면 순서를 정해서 단계적으로 위임하는 구조로 만든다.

* 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다.

* 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 다음 위임 대상도 인터페이스를 선언하고 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.

  → 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에서 미리 알 수 없다.

#### 프록시 패턴

* 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 클라이언트가 타깃에 접근하는 방식을 변경

  → 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.

* 타깃 오브젝트를 생성하기 복잡하거나 당장 필요하지 않아 꼭 필요한 시점까지 오브젝트를 생성하지 않으려고 하지만, 레퍼런스는 미리 필요할 때 주로 사용

  → 프록시의 메소드를 통해 타깃을 사용하려고 시도할 때, 프록시가 타깃 오브젝트를 생성하고 요청 위임



### 6.3.2 다이내믹 프록시

#### 프록시의 구성과 프록시 작성의 문제점

프록시는 다음의 두 가지 기능으로 구성된다.

* 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임
* 지정된 요청에 대해서 부가기능을 수행

프록시를 만들기가 번거로운 이유는 다음과 같다.

* 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다
  * 부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어야 한다.
* 부가기능 코드가 중복될 가능성이 많다.

위의 문제를 해결하는 데 유용한 것이 JDK의 다이내믹 프록시다.

#### 다이내믹 프록시 적용

: 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트

* 리플렉션 기능을 이용해 프록시를 생성
  * 리플렉션: 자바의 코드 자체를 추상화해서 접근하도록 만든 것

![img](../images/img.png)

1. 프록시 팩토리에 인터페이스 정보를 제공해주면 해당 인터페이스를 구현한 프록시를 자동으로 생성

2. 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담음

3. 다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메서드로 넘김

   → 타깃 인터페이스의 모든 메소드 요청이 하나의 메서드로 집중되어 중복 제거

![InvocationHandler](../images/InvocationHandler.png)

<장점>

* 인터페이스에 메소드가 추가되거나 수정되어도 코드를 수정할 필요가 없음
* 타깃의 종류와 상관없이 InvocationHandler 구현 클래스에 담긴 부가기능을 적용할 수 있음



### 6.3.4 다이내믹 프록시를 위한 팩토리 빈

* 팩토리 빈: 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가지고 빈 오브젝트를 생성한다. 그런데 다이내믹 프록시 오브젝트는 생성될 때 타입이 결정되기 때문에 설정 파일을 통해 빈으로 등록할 수 없다. 이때 다이내믹 프록시 오브젝트를 빈으로 등록하기 위한 **FactoryBean 인터페이스**를 구현한 오브젝트를 생성하고 이를 설정 파일에 등록한다. 그러면 스프링은 자기가 직접 빈을 생성하지 않고 **FactoryBean의 getObjectType()에 명시된 타입으로 FactoryBean의 getObject() 메서드를 통해 만들고자 하는 빈을 생성해서 등록**한다. 즉, 다이내믹 프록시 오브젝트의 복잡한 생성코드도 getObject() 안에 넣으면 되는 것이다.

#### 장점

* 한번 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용 가능
* 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거
* 하나의 핸들러 메소드로 많은 메소드에 부가기능을 부여할 수 있어 부가기능 코드의 중복 제거

#### 한계

* 여러 클래스의 메소드에 부가기능을 적용해야 한다면 프록시 팩토리 빈의 설정이 중복됨
* 하나의 클래스에 여러 개의 부가기능을 적용할 때도 프록시 팩토리 빈의 설정이 증가함
* 하나의 InvocationHandler 오브젝트가 해당 부가기능을 적용하려는 프록시 팩토리 빈 개수만큼 생성됨





## 6.4 스프링의 프록시 팩토리 빈

### 6.4.1 ProxyFactoryBean

* ProxyFactoryBean: 프록시를 생성해서 빈 오브젝트로 등록해주는 팩토리 빈
  
  * 순수하게 프록시 생성 작업만을 담당하며 부가기능은 MethodInterceptor 빈에 둘 수 있음
* MethodInterceptor: ProxyFactoryBean이 생성한 프록시에 사용할 부가기능을 담아둘 수 있는 인터페이스
  
  * ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보(MethodInvocation)까지도 함께 제공받기 때문에 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있음
  
    → 싱글톤 빈으로 등록 가능

#### 어드바이스: 타깃이 필요 없는 순수한 부가기능

* MethodInvocation: 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트 = **어드바이스(advice)**
  * 일종의 콜백 오브젝트
  * proceed() → 타깃 오브젝트의 메서드를 내부적으로 실행
* ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.
* addAdvice() 메서드를 통해 ProxyFactoryBean에 여러 개의 MethodInterceptor를 추가할 수 있다.
* ProxyFactoryBean은 인터페이스 자동검출 기능으로 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아내고, 알아낸 인터페이스 모두를 구현하는 프록시를 생성한다.

#### 포인트컷: 부가기능 적용 대상 메서드 선정 방법

* Pointcut: 메서드 선정 알고리즘을 담은 오브젝트

MethodInterceptor 오브젝트는 여러 프록시가 공유해서 사용할 수 있다. 그러기 위해서 MethodInterceptor 오브젝트는 타깃 정보를 갖고 있지 않도록 만들었다. 따라서, 트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 MethodInterceptor에 특정 프록시에만 적용되는 패턴을 넣으면 문제가 된다.